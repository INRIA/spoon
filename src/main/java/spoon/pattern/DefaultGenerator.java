/**
 * Copyright (C) 2006-2017 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
package spoon.pattern;

import spoon.pattern.node.RootNode;
import spoon.pattern.parameter.ParameterInfo;
import spoon.reflect.code.CtCodeElement;
import spoon.reflect.code.CtComment;
import spoon.reflect.cu.CompilationUnit;
import spoon.reflect.cu.SourcePosition;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtType;
import spoon.reflect.declaration.CtTypeMember;
import spoon.reflect.factory.Factory;
import spoon.support.SpoonClassNotFoundException;
import spoon.support.util.ParameterValueProvider;

/**
 * Drives generation process
 */
public class DefaultGenerator implements Generator {
	protected final Factory factory;
	private boolean addGeneratedBy = false;

	public DefaultGenerator(Factory factory) {
		super();
		this.factory = factory;
	}

	@Override
	public <T> void generateTargets(RootNode node, ResultHolder<T> result, ParameterValueProvider parameters) {
		node.generateTargets(this, result, parameters);
		if (node.isSimplifyGenerated()) {
			// simplify this element, it contains a substituted element
			result.mapEachResult(element -> {
				if (element instanceof CtCodeElement) {
					CtCodeElement code = (CtCodeElement) element;
					try {
						code = code.partiallyEvaluate();
						if (result.getRequiredClass().isInstance(code)) {
							return (T) code;
						}
						/*
						 * else the simplified code is not matching with required type. For example
						 * statement String.class.getName() was converted to expression
						 * "java.lang.String"
						 */
					} catch (SpoonClassNotFoundException e) {
						// ignore it. Do not simplify this element
						getFactory().getEnvironment()
								.debugMessage("Partial evaluation was skipped because of: " + e.getMessage());
					}
				}
				return element;
			});
		}
	}

	@Override
	public <T> void getValueAs(ParameterInfo parameterInfo, ResultHolder<T> result, ParameterValueProvider parameters) {
		parameterInfo.getValueAs(factory, result, parameters);
	}

	@Override
	public Factory getFactory() {
		return factory;
	}

	public boolean isAddGeneratedBy() {
		return addGeneratedBy;
	}

	public DefaultGenerator setAddGeneratedBy(boolean addGeneratedBy) {
		this.addGeneratedBy = addGeneratedBy;
		return this;
	}

	@Override
	public void applyGeneratedBy(CtElement generatedElement, CtElement templateElement) {
		if (isAddGeneratedBy() && generatedElement instanceof CtTypeMember) {
			String genBy = getGeneratedByComment(templateElement);
			if (genBy != null) {
				addGeneratedByComment(generatedElement, genBy);
			}
		}
	}
	private String getGeneratedByComment(CtElement ele) {
		SourcePosition pos = ele.getPosition();
		if (pos != null) {
			CompilationUnit cu = pos.getCompilationUnit();
			if (cu != null) {
				CtType<?> mainType = cu.getMainType();
				if (mainType != null) {
					StringBuilder result = new StringBuilder();
					result.append("Generated by ");
					result.append(mainType.getQualifiedName());
					appendInnerTypedElements(result, mainType, ele);
					result.append('(');
					result.append(mainType.getSimpleName());
					result.append(".java:");
					result.append(pos.getLine());
					result.append(')');
					return  result.toString();
				}
			}
		}
		return null;
	}
	private void appendInnerTypedElements(StringBuilder result, CtType<?> mainType, CtElement ele) {
		CtTypeMember typeMember = getFirst(ele, CtTypeMember.class);
		if (typeMember != null && typeMember != mainType) {
			if (typeMember.isParentInitialized()) {
				appendInnerTypedElements(result, mainType, typeMember.getParent());
			}
			if (typeMember instanceof CtType) {
				result.append('$');
			} else {
				result.append('#');
			}
			result.append(typeMember.getSimpleName());
		}
	}
	@SuppressWarnings("unchecked")
	private <T extends CtElement> T getFirst(CtElement ele, Class<T> clazz) {
		if (ele != null) {
			if (clazz.isAssignableFrom(ele.getClass())) {
				return (T) ele;
			}
			if (ele.isParentInitialized()) {
				return getFirst(ele.getParent(), clazz);
			}
		}
		return null;
	}

	private void addGeneratedByComment(CtElement ele, String generatedBy) {
		if (generatedBy == null) {
			return;
		}
		String EOL = System.getProperty("line.separator");
		CtComment comment = getJavaDoc(ele);
		String content = comment.getContent();
		if (content.trim().length() > 0) {
			content += EOL + EOL;
		}
		content += generatedBy;
		comment.setContent(content);
	}

	private CtComment getJavaDoc(CtElement ele) {
		for (CtComment comment : ele.getComments()) {
			if (comment.getCommentType() == CtComment.CommentType.JAVADOC) {
				return comment;
			}
		}
		CtComment c = ele.getFactory().Code().createComment("", CtComment.CommentType.JAVADOC);
		ele.addComment(c);
		return c;
	}

}
