//package spoon.pattern;
//
//import java.util.Collection;
//import java.util.Collections;
//import java.util.IdentityHashMap;
//import java.util.Map;
//import java.util.Set;
//
//import spoon.reflect.code.CtCodeElement;
//import spoon.reflect.code.CtComment;
//import spoon.reflect.cu.CompilationUnit;
//import spoon.reflect.cu.SourcePosition;
//import spoon.reflect.declaration.CtElement;
//import spoon.reflect.declaration.CtType;
//import spoon.reflect.declaration.CtTypeMember;
//import spoon.reflect.meta.RoleHandler;
//import spoon.reflect.meta.impl.RoleHandlerHelper;
//import spoon.support.SpoonClassNotFoundException;
//import spoon.support.visitor.equals.CloneHelper;
//
///**
// * Clones provided AST and substitutes required nodes and attributes using defined parameters
// */
//class SubstitutionCloner extends CloneHelper {
//	private final SubstitutionRequestProvider modelValueResolver;
//	private final ParameterValueProvider parameters;
//	/*
//	 * Set of parents of substituted elements, which might be potentially simplified (partially evaluated)
//	 */
//	Set<CtElement> toBeSimplifiedElements = Collections.newSetFromMap(new IdentityHashMap<>());
//
//	SubstitutionCloner(SubstitutionRequestProvider pattern, ParameterValueProvider parameters) {
//		super();
//		this.modelValueResolver = pattern;
//		this.parameters = parameters;
//	}
//
//	/**
//	 * Handle substitution of single value element.
//	 * Zero or one element can be result of substitution of `element`
//	 */
//	@Override
//	public <T extends CtElement> T clone(T origin) {
//		if (origin == null) {
//			return null;
//		}
//		//TODO refactor clone process by way it directly delivers correct CtRole. Next line has some performance impact
//		ResultHolder.Single<T> result = new ResultHolder.Single<>(getExpectedClassInParent(origin));
//		substituteOrClone(origin, result);
//		return result.getResult();
//	}
//
//	/**
//	 * Handle substitution of element in a collection.
//	 * Zero, one or more elements can be result of substitution of `element`
//	 */
//	@Override
//	protected <T extends CtElement> void addClone(Collection<T> targetCollection, T origin) {
//		//TODO refactor clone process by way it directly delivers correct CtRole. Next line has some performance impact
//		ResultHolder.Multiple<T> result = new ResultHolder.Multiple<>(getExpectedClassInParent(origin));
//		substituteOrClone(origin, result);
//		targetCollection.addAll(result.getResult());
//	}
//
//	/**
//	 * Handle substitution of element in a Map.
//	 * Zero or one element can be result of substitution of `element`
//	 */
//	@Override
//	protected <T extends CtElement> void addClone(Map<String, T> targetMap, String key, T originValue) {
//		//TODO refactor clone process by way it directly delivers correct CtRole. Next line has some performance impact
//		ResultHolder.Single<T> result = new ResultHolder.Single<>(getExpectedClassInParent(originValue));
//		substituteOrClone(originValue, result);
//		if (result.getResult() == null) {
//			//the pattern removes this element. Do not add it into target map
//			return;
//		}
//		targetMap.put(key, result.getResult());
//		return;
//	}
//
//	private <T> Class<T> getExpectedClassInParent(CtElement element) {
//		RoleHandler rh = RoleHandlerHelper.getRoleHandlerWrtParent(element);
//		if (rh == null) {
//			return null;
//		}
//		return (Class<T>) rh.getValueClass();
//	}
//
//	@SuppressWarnings("unchecked")
//	protected <T extends CtElement> void substituteOrClone(T origin, ResultHolder<T> result) {
//		String generatedBy = origin instanceof CtTypeMember ? getGeneratedByComment(origin) : null;
//		//substitute the origin element and write result into context
//		substituteOrClone2(origin, result);
//
//		if (generatedBy != null) {
//			//add generated by comment
//			result.mapEachResult(element -> {
//				if (element instanceof CtTypeMember) {
//					addGeneratedByComment(element, generatedBy);
//				}
//				return element;
//			});
//		}
//		if (toBeSimplifiedElements.remove(origin)) {
//			//simplify this element, it contains a substituted element
//			//TODO it would be nice if CloneHelper would directly set the required class, but it would need more changes...
//			if (origin.isParentInitialized()) {
//				RoleHandler rh = RoleHandlerHelper.getRoleHandlerWrtParent(origin);
//				if (rh != null) {
//					result.setRequiredClass(rh.getValueClass());
//				} else {
//					result.setRequiredClass(origin.getClass());
//				}
//			}
//			result.mapEachResult(element -> {
//				if (element instanceof CtCodeElement) {
//					CtCodeElement code = (CtCodeElement) element;
//					try {
//						code = code.partiallyEvaluate();
//						if (result.getRequiredClass().isInstance(code)) {
//							return (T) code;
//						}
//						/*
//						 * else the simplified code is not matching with required type.
//						 * For example statement String.class.getName() was converted to expression "java.lang.String"
//						 */
//					} catch (SpoonClassNotFoundException e) {
//						//ignore it. Do not simplify this element
//						origin.getFactory().getEnvironment().debugMessage("Partial evaluation was skipped because of: " + e.getMessage());
//					}
//				}
//				return element;
//			});
//		}
//	}
//
//	/**
//	 * Clones or substitutes origin element using {@link Node} of the role of this attribute
//	 * for `origin` element, then element is substituted
//	 * @param origin to be cloned or substituted element
//	 * @param result holder for result
//	 */
//	private <T extends CtElement> void substituteOrClone2(T origin, ResultHolder<T> result) {
//		Node valueResolver = modelValueResolver.getTemplateValueResolver(origin);
//		if ((valueResolver instanceof ConstantNode<?>) == false) {
//			//it is not just copying of node or substitution of node attributes
//			//the node is replaced by different 0, 1 or more nodes
//			planSimplification(origin.getParent());
//		}
//		valueResolver.generateTargets(factory, result, parameters);
//	}
//
//	private static String getGeneratedByComment(CtElement ele) {
//		SourcePosition pos = ele.getPosition();
//		if (pos != null) {
//			CompilationUnit cu = pos.getCompilationUnit();
//			if (cu != null) {
//				CtType<?> mainType = cu.getMainType();
//				if (mainType != null) {
//					StringBuilder result = new StringBuilder();
//					result.append("Generated by ");
//					result.append(mainType.getQualifiedName());
//					appendInnerTypedElements(result, mainType, ele);
//					result.append('(');
//					result.append(mainType.getSimpleName());
//					result.append(".java:");
//					result.append(pos.getLine());
//					result.append(')');
//					return  result.toString();
//				}
//			}
//		}
//		return null;
//	}
//
//	private static void appendInnerTypedElements(StringBuilder result, CtType<?> mainType, CtElement ele) {
//		CtTypeMember typeMember = getFirst(ele, CtTypeMember.class);
//		if (typeMember != null && typeMember != mainType) {
//			if (typeMember.isParentInitialized()) {
//				appendInnerTypedElements(result, mainType, typeMember.getParent());
//			}
//			if (typeMember instanceof CtType) {
//				result.append('$');
//			} else {
//				result.append('#');
//			}
//			result.append(typeMember.getSimpleName());
//		}
//	}
//
//	private static void addGeneratedByComment(CtElement ele, String generatedBy) {
//		if (generatedBy == null) {
//			return;
//		}
//		String EOL = System.getProperty("line.separator");
//		CtComment comment = getJavaDoc(ele);
//		String content = comment.getContent();
//		if (content.trim().length() > 0) {
//			content += EOL + EOL;
//		}
//		content += generatedBy;
//		comment.setContent(content);
//	}
//
//	private static CtComment getJavaDoc(CtElement ele) {
//		for (CtComment comment : ele.getComments()) {
//			if (comment.getCommentType() == CtComment.CommentType.JAVADOC) {
//				return comment;
//			}
//		}
//		CtComment c = ele.getFactory().Code().createComment("", CtComment.CommentType.JAVADOC);
//		ele.addComment(c);
//		return c;
//	}
//
//	@SuppressWarnings("unchecked")
//	private static <T extends CtElement> T getFirst(CtElement ele, Class<T> clazz) {
//		if (ele != null) {
//			if (clazz.isAssignableFrom(ele.getClass())) {
//				return (T) ele;
//			}
//			if (ele.isParentInitialized()) {
//				return getFirst(ele.getParent(), clazz);
//			}
//		}
//		return null;
//	}
//
//	/**
//	 * @param element to be cloned element
//	 * @return a clone which is not substituted
//	 */
//	public <T extends CtElement> T originClone(T element) {
//		T clone = super.clone(element);
//		if (clone instanceof CtType) {
//			SourcePosition pos = clone.getPosition();
//			if (pos != null) {
//				CompilationUnit cu = pos.getCompilationUnit();
//				if (cu != null && cu.getImports().size() > 0) {
//					//avoid usage of invalid template imports in generated code
//					//TODO - this is just dirty workaround, which removes imports for templates too - but it should be no big problem ...
//					cu.setImports(Collections.emptySet());
//				}
//			}
//		}
//		return clone;
//	}
//
//	/**
//	 * plans simplification of clone of `element` after cloning of it's children is finished
//	 * @param element origin (not cloned) element, whose clone has to be simplified
//	 */
//	private void planSimplification(CtElement element) {
//		toBeSimplifiedElements.add(element);
//	}
//}
