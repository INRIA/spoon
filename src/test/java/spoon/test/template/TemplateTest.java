/**
 * Copyright (C) 2006-2018 INRIA and contributors
 * Spoon - http://spoon.gforge.inria.fr/
 *
 * This software is governed by the CeCILL-C License under French law and
 * abiding by the rules of distribution of free software. You can use, modify
 * and/or redistribute the software under the terms of the CeCILL-C license as
 * circulated by CEA, CNRS and INRIA at http://www.cecill.info.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the CeCILL-C License for more details.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
package spoon.test.template;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import spoon.Launcher;
import spoon.SpoonException;
import spoon.compiler.SpoonResourceHelper;
import spoon.pattern.Match;
import spoon.reflect.code.CtBlock;
import spoon.reflect.code.CtExpression;
import spoon.reflect.code.CtForEach;
import spoon.reflect.code.CtIf;
import spoon.reflect.code.CtInvocation;
import spoon.reflect.code.CtStatement;
import spoon.reflect.code.CtTry;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtField;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.declaration.CtParameter;
import spoon.reflect.declaration.CtType;
import spoon.reflect.declaration.CtTypeMember;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtFieldReference;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.ModelConsistencyChecker;
import spoon.reflect.visitor.filter.NamedElementFilter;
import spoon.support.compiler.FileSystemFile;
import spoon.support.template.Parameters;
import spoon.template.*;
import spoon.test.template.testclasses.*;
import spoon.test.template.testclasses.bounds.CheckBound;
import spoon.test.template.testclasses.bounds.CheckBoundMatcher;
import spoon.test.template.testclasses.bounds.CheckBoundTemplate;
import spoon.test.template.testclasses.bounds.FooBound;
import spoon.test.template.testclasses.constructors.C1;
import spoon.test.template.testclasses.constructors.TemplateWithConstructor;
import spoon.test.template.testclasses.constructors.TemplateWithFieldsAndMethods;
import spoon.test.template.testclasses.constructors.TemplateWithFieldsAndMethods_Wrong;
import spoon.test.template.testclasses.inheritance.InterfaceTemplate;
import spoon.test.template.testclasses.inheritance.SubClass;
import spoon.test.template.testclasses.inheritance.SubTemplate;
import spoon.test.template.testclasses.inheritance.SuperClass;
import spoon.test.template.testclasses.inheritance.SuperTemplate;
import spoon.test.template.testclasses.logger.Logger;
import spoon.test.template.testclasses.logger.LoggerTemplateProcessor;
import spoon.testing.utils.LineSeperatorExtension;
import spoon.testing.utils.ModelUtils;

import java.io.File;
import java.io.Serializable;
import java.rmi.Remote;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static java.util.Arrays.asList;
import static org.hamcrest.CoreMatchers.is;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertSame;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.fail;
import static spoon.testing.utils.ModelUtils.getOptimizedString;

public class TemplateTest {

	private String newLine = "\n";

	/*
	 * Matches comments like:
	 * Generated by spoon.test.template.testclasses.inheritance.SuperTemplate#toBeOverriden(SuperTemplate.java:7)
	 * Generated by spoon.test.template.testclasses.inheritance.SubTemplate#methodWithTemplatedParameters(SubTemplate.java:20)
	 * Generated by spoon.test.template.testclasses.inheritance.SubTemplate#toBeOverriden(SubTemplate.java:16)
	 * Generated by spoon.test.template.testclasses.inheritance.SubTemplate#var(SubTemplate.java:51)
	 * Generated by spoon.test.template.testclasses.inheritance.SubTemplate$InnerClass(SubTemplate.java:76)
	 */
	private static final Pattern generatedByRE = Pattern.compile(".*Generated by ([^$#\\(]+)([^\\(]*)\\(([^\\.]+)\\.java:(\\d+)\\).*", Pattern.MULTILINE | Pattern.DOTALL);
	private static final Pattern typeMemberRE = Pattern.compile("[^\\.$#]+$");
	
	private void assertCommentHasGeneratedBy(CtElement e, String templateQName, Map<CtElement, String> elementToGeneratedByMember) {
		String docComment = e.getDocComment();
		String generatedByMember = elementToGeneratedByMember.get(e);
		if (generatedByMember == null) {
			assertEquals("", docComment);
//			assertTrue(e.getPosition().isValidPosition() == false);
		} else {
			assertNotNull("Javadoc comment is missing for "+e.toString(), docComment);
			int idx = docComment.indexOf("Generated by");
			assertTrue(idx>=0, "Javadoc comment doesn't contain Generated by. There is:\n"+docComment);
			Matcher m = generatedByRE.matcher(docComment);
			assertTrue(m.matches(), "Unexpected Generated by:\n"+docComment);
			assertEquals(templateQName, m.group(1));
			assertEquals(generatedByMember, m.group(2));
			assertTrue(templateQName.endsWith("."+m.group(3)));
			int lineNr = Integer.parseInt(m.group(4))-1;
			assertTrue(lineNr>=0);
			String[] sourceLines = e.getPosition().getCompilationUnit().getOriginalSourceCode().split("\\r\\n|\\r|\\n");
			assertTrue(sourceLines.length>lineNr);
			String sourceLine = sourceLines[lineNr];
			Matcher m2 = typeMemberRE.matcher(generatedByMember);
			assertTrue(m2.find());
			String memberSimpleName = m2.group();
			assertTrue(memberSimpleName.length()>2);
			assertTrue(sourceLine.contains(memberSimpleName), "Source file "+e.getPosition().getFile().getAbsolutePath()+":"+lineNr+" doesn't contain member name "+memberSimpleName);
		}
	}

	@Test
	public void testTemplateWithWrongUsedStringParam() throws Exception {
		Launcher spoon = new Launcher();
		Factory factory = spoon.createFactory();
		spoon.createCompiler(
				factory,
				SpoonResourceHelper
						.resources("./src/test/java/spoon/test/template/testclasses/constructors/C1.java"),
				SpoonResourceHelper
						.resources(
								"./src/test/java/spoon/test/template/testclasses/constructors/TemplateWithFieldsAndMethods_Wrong.java"))
				.build();

		CtClass<?> c1 = factory.Class().get(C1.class);

		new TemplateWithFieldsAndMethods_Wrong(
				"testparam").apply(c1);

		CtMethod<?> m = c1.getMethod("methodToBeInserted");
		assertNotNull(m);
		//contract: printing of code which contains invalid field reference, fails with nice exception
		try {
			m.getBody().getStatement(0).toString();
		} catch (SpoonException e) {
			assertTrue(e.getMessage().contains("testparam"), "The error description doesn't contain name of invalid field. There is:\n" + e.getMessage());
		}
	}

	@Test
	public void testCheckBoundTemplate() throws Exception {
		Launcher spoon = new Launcher();
		Factory factory = spoon.createFactory();
		spoon.createCompiler(
				factory,
				SpoonResourceHelper.resources(
						"./src/test/java/spoon/test/template/testclasses/bounds/FooBound.java"),
				SpoonResourceHelper
						.resources(
								"./src/test/java/spoon/test/template/testclasses/bounds/CheckBoundTemplate.java"))
				.build();

		CtClass<?> c = factory.Class().get(FooBound.class);

		CtMethod<?> method = c.getMethodsByName("method").get(0);

		assertEquals(1, Parameters.getAllTemplateParameterFields(CheckBoundTemplate.class).size());
		assertEquals(1, Parameters.getAllTemplateParameterFields(CheckBoundTemplate.class, factory).size());

		// creating a template instance
		CheckBoundTemplate t = new CheckBoundTemplate();
		assertTrue(t.isWellFormed());
		assertFalse(t.isValid());
		CtParameter<?> param = method.getParameters().get(0);
		t.setVariable(param);
		assertTrue(t.isValid());

		// getting the final AST
		CtStatement injectedCode = (t.apply(c));

		assertTrue(injectedCode instanceof CtIf);

		CtIf ifStmt = (CtIf) injectedCode;

		// contains the replaced code
		assertEquals("l.size() > 10", ifStmt.getCondition().toString());

		// adds the bound check at the beginning of a method
		method.getBody().insertBegin(injectedCode);
		assertEquals(injectedCode, method.getBody().getStatement(0));
	}

	@Test
	public void testAbstractTemplateIsWellFormed() {
		// contract: IsWellFormed method of AbstractTemplate class returns false if there are zero template parameter

		AbstractTemplate<CtElement> zeroParameterTemplate = new AbstractTemplate<CtElement>() {
			@Override
			public CtElement apply(CtType<?> targetType) {
				return null;
			}
		};

		assertFalse(zeroParameterTemplate.isWellFormed());
	}

	@Test
	public void testTemplateMatcher() throws Exception {
		// contract: the given templates should match the expected elements
		Launcher spoon = new Launcher();
		Factory factory = spoon.getFactory();
		spoon.createCompiler(
				factory,
				SpoonResourceHelper.resources("./src/test/java/spoon/test/template/testclasses/bounds/CheckBound.java"),
				SpoonResourceHelper.resources("./src/test/java/spoon/test/template/testclasses/bounds/CheckBoundMatcher.java"))
				.build();

		{// testing matcher1
			CtClass<?> templateKlass = factory.Templates().Class().get(CheckBoundMatcher.class);
			CtClass<?> klass = factory.Class().get(CheckBound.class);
			CtIf templateRoot = (CtIf) ((CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher1")).get(0)).getBody().getStatement(0);
			TemplateMatcher matcher = new TemplateMatcher(templateRoot);
			assertEquals(2, matcher.find(klass).size());
			assertThat(asList("foo","fbar"), is(klass.filterChildren(matcher).map((CtElement e)->getMethodName(e)).list())) ;
			matcher.forEachMatch(klass, (match) -> {
				assertTrue(checkParameters("foo", match, "_col_", "new java.util.ArrayList<>()")
						|| checkParameters("fbar", match, "_col_", "l")
				);
			});
		}

		{// testing matcher2
			CtClass<?> templateKlass = factory.Templates().Class().get(CheckBoundMatcher.class);
			CtClass<?> klass = factory.Class().get(CheckBound.class);
			CtIf templateRoot = (CtIf) ((CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher2")).get(0)).getBody().getStatement(0);
			TemplateMatcher matcher = new TemplateMatcher(templateRoot);
			assertEquals(2, matcher.find(klass).size());
			assertThat(asList("bou", "bov"), is(klass.filterChildren(matcher).map((CtElement e)->getMethodName(e)).list())) ;
			matcher.forEachMatch(klass, (match) -> {
				assertTrue(checkParameters("bov", match, "_col_", "new java.util.ArrayList<>()")
						|| checkParameters("bou", match, "_col_", "new java.util.ArrayList<>()"));
			});
		}

		{// testing matcher3
			CtClass<?> templateKlass = factory.Templates().Class().get(CheckBoundMatcher.class);
			CtClass<?> klass = factory.Class().get(CheckBound.class);
			CtIf templateRoot = (CtIf) ((CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher3")).get(0)).getBody().getStatement(0);
			TemplateMatcher matcher = new TemplateMatcher(templateRoot);
			assertEquals(2, matcher.find(klass).size());
			assertThat(asList("foo","fbar"), is(klass.filterChildren(matcher).map((CtElement e)->getMethodName(e)).list())) ;
			matcher.forEachMatch(klass, (match) -> {
				assertTrue(checkParameters("foo", match, "_x_", "new java.util.ArrayList<>().size()")
						||checkParameters("fbar", match, "_x_", "l.size()")
				);
			});
		}

		{// testing matcher4
			CtClass<?> templateKlass = factory.Templates().Class().get(CheckBoundMatcher.class);
			CtClass<?> klass = factory.Class().get(CheckBound.class);
			CtIf templateRoot = (CtIf) ((CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher4")).get(0)).getBody().getStatement(0);
			TemplateMatcher matcher = new TemplateMatcher(templateRoot);
			assertEquals(3, matcher.find(klass).size());
			assertThat(asList("foo","foo2","fbar"), is(klass.filterChildren(matcher).map((CtElement e)->getMethodName(e)).list())) ;
			matcher.forEachMatch(klass, (match) -> {
				assertTrue(
						checkParameters("foo", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "10")
						||checkParameters("foo2", match, 
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "11")
						||checkParameters("fbar", match,
								"_x_", "l.size()",
								"_y_", "10")
				);
			});
		}

		{// testing matcher5
			CtClass<?> templateKlass = factory.Templates().Class().get(CheckBoundMatcher.class);
			CtClass<?> klass = factory.Class().get(CheckBound.class);
			CtIf templateRoot = (CtIf) ((CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher5")).get(0)).getBody().getStatement(0);
			TemplateMatcher matcher = new TemplateMatcher(templateRoot);
			assertEquals(6, matcher.find(klass).size());
			assertThat(asList("foo","foo2","fbar","baz","bou","bov"), is(klass.filterChildren(matcher).map((CtElement e)->getMethodName(e)).list())) ;
			matcher.forEachMatch(klass, (match) -> {
				assertTrue(
						checkParameters("foo", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "10",
								"_block_", "{ throw new java.lang.IndexOutOfBoundsException();}")
						||checkParameters("foo2", match, 
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "11",
								"_block_", "{ throw new java.lang.IndexOutOfBoundsException();}")
						||checkParameters("fbar", match,
								"_x_", "l.size()",
								"_y_", "10",
								"_block_", "{ throw new java.lang.IndexOutOfBoundsException();}")
						||checkParameters("baz", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "10",
								"_block_", "{}")
						||checkParameters("bou", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "10",
								"_block_", "{ java.lang.System.out.println();}")
						||checkParameters("bov", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "10",
								"_block_", "{ java.lang.System.out.println();}")
				);
			});
		}

		{// testing matcher6
			CtClass<?> templateKlass = factory.Templates().Class().get(CheckBoundMatcher.class);
			CtClass<?> klass = factory.Class().get(CheckBound.class);
			CtIf templateRoot = (CtIf) ((CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher6")).get(0)).getBody().getStatement(0);
			TemplateMatcher matcher = new TemplateMatcher(templateRoot);
			assertEquals(6, matcher.find(klass).size());
			assertThat(asList("foo","foo2","fbar","baz","bou","bov"), is(klass.filterChildren(matcher).map((CtElement e)->getMethodName(e)).list())) ;
			matcher.forEachMatch(klass, (match) -> {
				assertTrue(
						checkParameters("foo", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "10",
								"_stmt_", "throw new java.lang.IndexOutOfBoundsException()")
						||checkParameters("foo2", match, 
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "11",
								"_stmt_", "throw new java.lang.IndexOutOfBoundsException()")
						||checkParameters("fbar", match,
								"_x_", "l.size()",
								"_y_", "10",
								"_stmt_", "throw new java.lang.IndexOutOfBoundsException()")
						||checkParameters("baz", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "10",
								"_stmt_", "null")
						||checkParameters("bou", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "10",
								"_stmt_", "java.lang.System.out.println()")
						||checkParameters("bov", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_y_", "10",
								"_stmt_", "java.lang.System.out.println()")
				);
			});
		}

		{// testing matcher7
			CtClass<?> templateKlass = factory.Templates().Class().get(CheckBoundMatcher.class);
			CtClass<?> klass = factory.Class().get(CheckBound.class);
			CtIf templateRoot = (CtIf) ((CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher7")).get(0)).getBody().getStatement(0);
			TemplateMatcher matcher = new TemplateMatcher(templateRoot);
			assertEquals(1, matcher.find(klass).size());
			assertThat(asList("bos"), is(klass.filterChildren(matcher).map((CtElement e)->getMethodName(e)).list())) ;
			matcher.forEachMatch(klass, (match) -> {
				assertTrue(
						checkParameters("bos", match,
								"_x_", "new java.util.ArrayList<>().size()",
								"_block_", "{ java.lang.System.out.println();}")
				);
			});
		}

		// testing with named elements, at the method level
		{
			CtClass<?> templateKlass = factory.Templates().Class().get(CheckBoundMatcher.class);
			CtClass<?> klass = factory.Class().get(CheckBound.class);
			CtMethod meth = (CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher3")).get(0);

			// exact match
			meth.setSimpleName("foo");
			TemplateMatcher matcher = new TemplateMatcher(meth);
			List<CtMethod> ctElements = matcher.find(klass);
			assertEquals(1, ctElements.size());
			assertEquals("foo", ctElements.get(0).getSimpleName());
		}

		{
			// contract: the name to be matched does not have to be an exact match
			CtClass<?> templateKlass = factory.Templates().Class().get(CheckBoundMatcher.class);
			CtClass<?> klass = factory.Class().get(CheckBound.class);
			CtMethod meth = (CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher5")).get(0);

			// together with the appropriate @Parameter _w_, this means
			// we match all methods with name f*, because parameter _w_ acts as a wildcard
			meth.setSimpleName("f_w_");
			TemplateMatcher matcher = new TemplateMatcher(meth);
			List<CtMethod> ctElements = matcher.find(klass);
			assertEquals(3, ctElements.size());
			assertEquals("foo", ctElements.get(0).getSimpleName());
			assertEquals("foo2", ctElements.get(1).getSimpleName());
			assertEquals("fbar", ctElements.get(2).getSimpleName());
		}
	}
	
	private boolean checkParameters(String methodName, Match match, String... keyValues) {
		if (methodName.equals(getMethodName(match.getMatchingElement()))) {
			assertEquals(0, keyValues.length % 2, "The arguments of keyValues must be in pairs");
			Map<String, Object> allParams = new HashMap<>(match.getParameters().asMap());
			int count = keyValues.length / 2;
			for (int i = 0; i < count; i++) {
				String key = keyValues[i * 2];
				String expectedValue = keyValues[i * 2 + 1];
				Object realValue = allParams.remove(key);
				assertEquals(expectedValue, getOptimizedString(realValue), "parameter " + key);
			}
			assertTrue(allParams.isEmpty(), "Unexpected parameter values: " + allParams);
			return true;
		}
		return false;
	}

	private String getMethodName(CtElement e) {
		return e.getParent(CtMethod.class).getSimpleName();
	}

	@Test
	public void testExtensionBlock() {
		final Launcher launcher = new Launcher();
		launcher.setArgs(new String[] {"--output-type", "nooutput" });
		launcher.addInputResource("./src/test/java/spoon/test/template/testclasses/logger/Logger.java");
		launcher.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/logger/LoggerTemplate.java"));
		launcher.addProcessor(new LoggerTemplateProcessor());
		launcher.getEnvironment().setSourceClasspath(System.getProperty("java.class.path").split(File.pathSeparator));
		try {
			launcher.run();
		} catch (ClassCastException ignored) {
			fail();
		}

		final CtClass<Logger> aLogger = launcher.getFactory().Class().get(Logger.class);
		final CtMethod aMethod = aLogger.getMethodsByName("enter").get(0);
		assertTrue(aMethod.getBody().getStatement(0) instanceof CtTry);
		final CtTry aTry = (CtTry) aMethod.getBody().getStatement(0);
		assertTrue(aTry.getFinalizer().getStatement(0) instanceof CtInvocation);
		assertEquals("spoon.test.template.testclasses.logger.Logger.exit(\"enter\")", aTry.getFinalizer().getStatement(0).toString());
		assertTrue(aTry.getBody().getStatement(0) instanceof CtInvocation);
		assertEquals("spoon.test.template.testclasses.logger.Logger.enter(\"Logger\", \"enter\")", aTry.getBody().getStatement(0).toString());
		assertTrue(aTry.getBody().getStatements().size() > 1);
		assertEquals("java.lang.System.out.println(((\"enter: \" + className) + \" - \") + methodName)", aTry.getBody().getStatement(1).toString());
	}

	@Test
	public void testTemplateInterfaces() throws Exception {
		Launcher spoon = new Launcher();
		Factory factory = spoon.getFactory();
		spoon.createCompiler(
				factory,
				SpoonResourceHelper.resources(
						"./src/test/java/spoon/test/template/testclasses/inheritance/SubClass.java"),
				SpoonResourceHelper
						.resources(
								"./src/test/java/spoon/test/template/testclasses/inheritance/InterfaceTemplate.java")
				)
				.build();

		CtClass<?> superc = factory.Class().get(SuperClass.class);
		InterfaceTemplate interfaceTemplate = new InterfaceTemplate(superc.getFactory());
		interfaceTemplate.apply(superc);

		assertEquals(3, superc.getSuperInterfaces().size());
		assertTrue(superc.getSuperInterfaces().contains(factory.Type().createReference(Comparable.class)));
		assertTrue(superc.getSuperInterfaces().contains(factory.Type().createReference(Serializable.class)));
		assertTrue(superc.getSuperInterfaces().contains(factory.Type().createReference(Remote.class)));
	}

	@Test
	public void testSimpleTemplate() {
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/SimpleTemplate.java"));
		spoon.buildModel();

		Factory factory = spoon.getFactory();

		CtClass<?> testSimpleTpl = factory.Class().create("TestSimpleTpl");
		//whitespace seems wrong here
		new SimpleTemplate("HelloWorld").apply(testSimpleTpl);

		Set<CtMethod<?>> listMethods = testSimpleTpl.getMethods();
		assertEquals(0, testSimpleTpl.getMethodsByName("apply").size());
		assertEquals(1, listMethods.size());
	}

	@Test
	public void testTemplateMatcherWithWholePackage() {
		Launcher spoon = new Launcher();
		spoon.addInputResource("./src/test/java/spoon/test/template/testclasses/ContextHelper.java");
		spoon.addInputResource("./src/test/java/spoon/test/template/testclasses/BServiceImpl.java");

		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/SecurityCheckerTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		CtClass<?> templateKlass = factory.Templates().Class().get(SecurityCheckerTemplate.class);
		CtMethod templateMethod = (CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher1")).get(0);
		CtIf templateRoot = (CtIf) templateMethod.getBody().getStatement(0);
		TemplateMatcher matcher = new TemplateMatcher(templateRoot);

		List<CtElement> matches = matcher.find(factory.getModel().getRootPackage());

		assertEquals(1, matches.size());

		CtElement match = matches.get(0);

		assertTrue(match instanceof CtIf, "Match is not a if");

		CtElement matchParent = match.getParent();

		assertTrue(matchParent instanceof CtBlock, "Match parent is not a block");

		CtElement matchParentParent = matchParent.getParent();

		assertTrue(matchParentParent instanceof CtMethod, "Match grand parent is not a method");

		CtMethod methodHello = (CtMethod)matchParentParent;

		assertEquals("hello", methodHello.getSimpleName(), "Match grand parent is not a method called hello");

		CtElement methodParent = methodHello.getParent();

		assertTrue(methodParent instanceof CtClass, "Parent of the method is not a class");

		CtClass bservice = (CtClass) methodParent;

		assertEquals("BServiceImpl", bservice.getSimpleName(), "Parent of the method is not a class called BServiceImpl");
	}

	@Test
	public void testTemplateMatcherMatchTwoSnippets() {
		Launcher spoon = new Launcher();
		spoon.addInputResource("./src/test/java/spoon/test/template/testclasses/TwoSnippets.java");
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/SecurityCheckerTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		CtClass<?> templateKlass = factory.Templates().Class().get(SecurityCheckerTemplate.class);
		CtMethod templateMethod = (CtMethod) templateKlass.getElements(new NamedElementFilter<>(CtMethod.class,"matcher1")).get(0);
		CtIf templateRoot = (CtIf) templateMethod.getBody().getStatement(0);
		TemplateMatcher matcher = new TemplateMatcher(templateRoot);

		//match byFieldAccessOnVariableusing legacy TemplateMatcher#find method
		List<CtElement> matches = matcher.find(factory.getModel().getRootPackage());

		assertEquals(2, matches.size());

		CtElement match1 = matches.get(0);
		CtElement match2 = matches.get(1);

		assertTrue(match1.equals(match2));
		
		//match using TemplateMatcher#matches method and query filter
		matches = factory.getModel().filterChildren(matcher).list();

		assertEquals(2, matches.size());

		match1 = matches.get(0);
		match2 = matches.get(1);

		assertTrue(match1.equals(match2));
	}
	@Test
	public void testTemplateInvocationSubstitution() {
		//contract: the template engine supports substitution of method names in method calls.
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/InvocationTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		CtClass<?> resultKlass = factory.Class().create("Result");
		new InvocationTemplate(factory.Type().OBJECT, "hashCode").apply(resultKlass);
		CtMethod<?> templateMethod = (CtMethod<?>) resultKlass.getElements(new NamedElementFilter<>(CtMethod.class,"invoke")).get(0);
		CtStatement templateRoot = (CtStatement) templateMethod.getBody().getStatement(0);
		//iface.$method$() becomes iface.hashCode()
		assertEquals("iface.hashCode()", templateRoot.toString());
	}

	@Test
	public void testSubstitutionInsertAllNtoN() {
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/NtonCodeTemplate.java"));
		spoon.addInputResource("./src/test/java/spoon/test/template/testclasses/C.java");
		spoon.buildModel();

		Factory factory = spoon.getFactory();

		CtClass<?> cclass = factory.Class().get("spoon.test.template.testclasses.C");
		new NtonCodeTemplate(cclass.getReference(), 5).apply(cclass);

		Set<CtMethod<?>> listMethods = cclass.getMethods();
		assertEquals(0, cclass.getMethodsByName("apply").size());
		assertEquals(4, listMethods.size());
	}

	@Test
	public void testSubstituteInnerClass() {
		//contract: the inner class is substituted well too and references to target class are substituted well
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/InnerClassTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		CtClass<?> result = factory.Class().create("x.Result");
		new InnerClassTemplate().apply(result);
		assertEquals(1, result.getNestedTypes().size());
		CtType<?> innerType = result.getNestedType("Inner");
		assertNotNull(innerType);
		CtField<?> innerField = innerType.getField("innerField");
		assertNotNull(innerField);
		assertSame(innerType, innerField.getDeclaringType());
		CtFieldReference<?> fr = innerType.filterChildren((CtFieldReference<?> e)->true).first();
		//check that reference to declaring type is correctly substituted
		assertEquals("x.Result$Inner",fr.getDeclaringType().getQualifiedName());
	}

	@Test
	public void testStatementTemplateRootSubstitution() {
		//contract: the template engine supports substitution of root element
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/SubstituteRootTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		CtClass<?> templateClass = factory.Templates().Class().get(SubstituteRootTemplate.class);
		CtBlock<Void> templateParam = (CtBlock) templateClass.getMethod("sampleBlock").getBody();
		
		CtClass<?> resultKlass = factory.Class().create("Result");
		CtStatement result = new SubstituteRootTemplate(templateParam).apply(resultKlass);
		assertEquals("java.lang.String s = \"Spoon is cool!\"", ((CtBlock)result).getStatement(0).toString());
	}

	@Test
	public void testExpressionTemplate() {
		//contract: the template engine supports expression templates
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/AnExpressionTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		CtClass<? extends ExpressionTemplate<?>> templateClass = factory.Templates().Class().get(AnExpressionTemplate.class);

		assertEquals("new java.lang.String(exp.S())", ExpressionTemplate.getExpression(templateClass).toString());


		CtClass<?> resultKlass = factory.Class().create("Result");
		CtExpression result = new AnExpressionTemplate(factory.createCodeSnippetExpression("\"Spoon is cool!\"")).apply(resultKlass);
		assertFalse(result.isParentInitialized());
		assertEquals("new java.lang.String(\"Spoon is cool!\")", result.toString());
	}
	
	@Test
	public void substituteSubString() {
		//contract: the substitution of substrings works on named elements and references too
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/SubStringTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		{
			//contract: String value is substituted in substring of literal, named element and reference
			final CtClass<?> result = (CtClass<?>) new SubStringTemplate("A").apply(factory.createClass());
			assertEquals("java.lang.String m_A = \"A is here more times: A\";", result.getField("m_A").toString());
			//contract: the parameter of type string replaces substring in method name
			CtMethod<?> method1 = result.getMethodsByName("setA").get(0);
			assertEquals("setA", method1.getSimpleName());
			assertEquals("java.lang.String p_A", method1.getParameters().get(0).toString());
			assertEquals("this.m_A = p_A", method1.getBody().getStatement(0).toString());
			assertEquals("setA(\"The A is here too\")", result.getMethodsByName("m").get(0).getBody().getStatements().get(0).toString());
		}
		{
			//contract: Type value name is substituted in substring of literal, named element and reference
			final CtClass<?> result = (CtClass<?>) new SubStringTemplate(factory.Type().OBJECT.getTypeDeclaration()).apply(factory.createClass());
			assertEquals("java.lang.String m_Object = \"Object is here more times: Object\";", result.getField("m_Object").toString());
			//contract: the parameter of type string replaces substring in method name
			CtMethod<?> method1 = result.getMethodsByName("setObject").get(0);
			assertEquals("setObject", method1.getSimpleName());
			assertEquals("java.lang.String p_Object", method1.getParameters().get(0).toString());
			assertEquals("this.m_Object = p_Object", method1.getBody().getStatement(0).toString());
			assertEquals("setObject(\"The Object is here too\")", result.getMethodsByName("m").get(0).getBody().getStatements().get(0).toString());
		}
		{
			//contract: Type reference value name is substituted in substring of literal, named element and reference
			final CtClass<?> result = (CtClass<?>) new SubStringTemplate(factory.Type().OBJECT).apply(factory.createClass());
			assertEquals("java.lang.String m_Object = \"Object is here more times: Object\";", result.getField("m_Object").toString());
			//contract: the parameter of type string replaces substring in method name
			CtMethod<?> method1 = result.getMethodsByName("setObject").get(0);
			assertEquals("setObject", method1.getSimpleName());
			assertEquals("java.lang.String p_Object", method1.getParameters().get(0).toString());
			assertEquals("this.m_Object = p_Object", method1.getBody().getStatement(0).toString());
			assertEquals("setObject(\"The Object is here too\")", result.getMethodsByName("m").get(0).getBody().getStatements().get(0).toString());
		}
		{
			//contract: String literal value name is substituted in substring of literal, named element and reference
			final CtClass<?> result = (CtClass<?>) new SubStringTemplate(factory.createLiteral("Xxx")).apply(factory.createClass());
			assertEquals("java.lang.String m_Xxx = \"Xxx is here more times: Xxx\";", result.getField("m_Xxx").toString());
			//contract: the parameter of type string replaces substring in method name
			CtMethod<?> method1 = result.getMethodsByName("setXxx").get(0);
			assertEquals("setXxx", method1.getSimpleName());
			assertEquals("java.lang.String p_Xxx", method1.getParameters().get(0).toString());
			assertEquals("this.m_Xxx = p_Xxx", method1.getBody().getStatement(0).toString());
			assertEquals("setXxx(\"The Xxx is here too\")", result.getMethodsByName("m").get(0).getBody().getStatements().get(0).toString());
		}
		{
			//contract: The elements which cannot be converted to String should throw exception
			SubStringTemplate template = new SubStringTemplate(factory.createSwitch());
			try {
				template.apply(factory.createClass());
				fail();
			} catch(SpoonException e) {
				//OK
			}
		}
	}

	@Test
	public void testObjectIsNotParamTemplate() {
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/ObjectIsNotParamTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();
		//contract: String value is substituted in substring of literal, named element and reference
		final CtClass<?> result = (CtClass<?>) new ObjectIsNotParamTemplate().apply(factory.createClass());
		assertEquals(0, result.getMethodsByName("methXXXd").size());
		assertEquals(1, result.getMethodsByName("method").size());
	}

	@Test
	public void testFieldAccessNameSubstitution() {
		//contract: the substitution of name of whole field is possible
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/FieldAccessTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		{
			//contract: String value is substituted in String literal
			final CtClass<?> result = (CtClass<?>) new FieldAccessTemplate("value").apply(factory.Class().create("x.X"));
			assertEquals("int value;", result.getField("value").toString());
			
			assertEquals("value = 7", result.getMethodsByName("m").get(0).getBody().getStatement(0).toString());
		}
	}

	@Test
	public void testFieldAccessNameSubstitutionInInnerClass() {
		//contract: the substitution of name of whole field is possible in inner class too
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/FieldAccessOfInnerClassTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		{
			//contract: String value is substituted in String literal
			final CtClass<?> result = (CtClass<?>) new FieldAccessOfInnerClassTemplate("value").apply(factory.Class().create("x.X"));
			final CtClass<?> innerClass = result.getNestedType("Inner");
			assertEquals("int value;", innerClass.getField("value").toString());
			
			assertEquals("value = 7", innerClass.getMethodsByName("m").get(0).getBody().getStatement(0).toString());
		}
	}

	@Test
	public void testAnotherFieldAccessNameSubstitution() {
		//contract: the substitution of name of whole field is possible
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/AnotherFieldAccessTemplate.java"));

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		{
			//contract: String value is substituted in String literal
			final CtClass<?> result = (CtClass<?>) new AnotherFieldAccessTemplate().apply(factory.Class().create("x.X"));
			assertEquals("int x;", result.getField("x").toString());
			assertEquals("int m_x;", result.getField("m_x").toString());

			assertEquals("java.lang.System.out.println(x + m_x)", result.getAnonymousExecutables().get(0).getBody().getStatement(0).toString());
		}
	}

	@Test
	public void substituteTypeAccessReference() {
		//contract: the substitution of CtTypeAccess expression ignores actual type arguments if it have to
		Launcher spoon = new Launcher();
		spoon.addTemplateResource(new FileSystemFile("./src/test/java/spoon/test/template/testclasses/TypeReferenceClassAccessTemplate.java"));
		String outputDir = "./target/spooned/test/template/testclasses";
		spoon.setSourceOutputDirectory(outputDir);

		spoon.buildModel();
		Factory factory = spoon.getFactory();

		//contract: String value is substituted in substring of literal, named element and reference
		CtTypeReference<?> typeRef = factory.Type().createReference("spoon.test.template.TypeReferenceClassAccess$Example");
		typeRef.addActualTypeArgument(factory.Type().DATE);
		
		final CtClass<?> result = (CtClass<?>) new TypeReferenceClassAccessTemplate(typeRef).apply(factory.Class().create("spoon.test.template.TypeReferenceClassAccess"));
		spoon.prettyprint();
		ModelUtils.canBeBuilt(outputDir, 8);
		CtMethod<?> method = result.getMethodsByName("someMethod").get(0);
		assertEquals("spoon.test.template.TypeReferenceClassAccess.Example<java.util.Date>", method.getType().toString());
		assertEquals("spoon.test.template.TypeReferenceClassAccess.Example<java.util.Date>", method.getParameters().get(0).getType().toString());
		assertEquals("o = spoon.test.template.TypeReferenceClassAccess.Example.out", method.getBody().getStatement(0).toString());
		assertEquals("spoon.test.template.TypeReferenceClassAccess.Example<java.util.Date> ret = new spoon.test.template.TypeReferenceClassAccess.Example<java.util.Date>()", method.getBody().getStatement(1).toString());
		assertEquals("o = spoon.test.template.TypeReferenceClassAccess.Example.currentTimeMillis()", method.getBody().getStatement(2).toString());
		assertEquals("o = spoon.test.template.TypeReferenceClassAccess.Example.class", method.getBody().getStatement(3).toString());
		assertEquals("o = o instanceof spoon.test.template.TypeReferenceClassAccess.Example<?>", method.getBody().getStatement(4).toString());
		assertEquals("java.util.function.Supplier<java.lang.Long> p = spoon.test.template.TypeReferenceClassAccess.Example::currentTimeMillis", method.getBody().getStatement(5).toString());
	}

	@Test
	public void testMethodCast() throws Exception {
		//contract: matcher should match methods with cast too
		//https://github.com/INRIA/spoon/issues/3026
		Launcher spoon = new Launcher();
		Factory factory = spoon.getFactory();
		spoon.createCompiler(
				factory,
				SpoonResourceHelper.resources("./src/test/java/spoon/test/template/testclasses/Flow.java"),
				SpoonResourceHelper.resources("./src/test/java/spoon/test/template/testclasses/FlowMatcher.java"))
				.build();

		CtClass<?> templateKlass = factory.Templates().Class().get(FlowMatcher.class);
		CtClass<?> klass = factory.Class().get(Flow.class);

		CtMethod<?> method = (CtMethod<?>) templateKlass.getElements(new NamedElementFilter(CtMethod.class, "subFlowMatcher")).get(0);
		CtElement templateRoot = method.getBody().getStatement(0);
		TemplateMatcher myMatcher = new TemplateMatcher(templateRoot);
		assertEquals(2, myMatcher.find(klass).size());
	}
}
