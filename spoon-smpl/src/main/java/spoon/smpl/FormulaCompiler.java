package spoon.smpl;

import fr.inria.controlflow.BranchKind;
import fr.inria.controlflow.ControlFlowNode;
import org.apache.commons.lang3.NotImplementedException;
import spoon.reflect.code.*;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtMethod;
import spoon.smpl.formula.*;
import spoon.smpl.formula.Optional;

import java.util.*;

/**
 * FormulaCompiler compiles CTL-VW Formulas from a given SmPL-adapted CFG of a method body in
 * the SmPL Java DSL (domain-specific language) of spoon-smpl, as generated by SmPLParser.
 */
public class FormulaCompiler {
    /**
     * Create a new FormulaCompiler.
     *
     * @param cfg SmPL-adapted CFG to produce formula from
     * @param metavars Metavariable names and their constraints
     * @param commonLines Set of line numbers of context statements common to both addition and deletion perspectives
     * @param additions Map of line-anchored addition operations
     */
    public FormulaCompiler(SmPLMethodCFG cfg, Map<String, MetavariableConstraint> metavars, Set<Integer> commonLines, AnchoredOperationsMap additions) {
        this.cfg = cfg;
        this.quantifiedMetavars = new ArrayList<>();
        this.metavars = metavars;
        this.commonLines = commonLines;
        this.additions = additions;
    }

    /**
     * Compile the CTL-VW Formula.
     *
     * @return CTL-VW Formula
     */
    public Formula compileFormula() {
        quantifiedMetavars = new ArrayList<>();
        metavarsToQuantifyOutermost = new ArrayList<>();

        Formula formula = compileFormulaInner(cfg.findNodesOfKind(BranchKind.BEGIN).get(0).next().get(0), null);
        formula = FormulaOptimizer.optimizeFully(formula);

        Collections.sort(metavarsToQuantifyOutermost);
        Collections.reverse(metavarsToQuantifyOutermost);

        for (String var : metavarsToQuantifyOutermost) {
            formula = new ExistsVar(var, formula);
        }

        return formula;
    }

    /**
     * Compile a CTL-VW Formula.
     * 
     * @param node First node of control flow graph to generate formula for
     * @param cutoffNodes Nodes at which formula compilation should stop
     * @return CTL-VW Formula
     */
    private Formula compileFormulaInner(ControlFlowNode node, List<ControlFlowNode> cutoffNodes) {
        Formula formula;
        Formula innerFormula;
        SmPLMethodCFG.NodeTag tag;

        try {
            tag = (SmPLMethodCFG.NodeTag) node.getTag();
        } catch (ClassCastException e) {
            tag = null;
        }

        if (cutoffNodes != null) {
            for (ControlFlowNode someNode : cutoffNodes) {
                if (someNode == node) {
                    return null;
                }
            }
        }

        if (node.getKind() == BranchKind.EXIT) {
            return new Proposition("end");
        } else if (SmPLMethodCFG.isMethodHeaderNode(node)) {
            return compileMethodHeaderFormula(node, cutoffNodes);
        } else {
            switch (node.next().size()) {
                case 0:
                    throw new IllegalArgumentException("Control flow node with no outgoing path");

                case 1:
                    switch (node.getKind()) {
                        case STATEMENT:
                            return compileStatementFormula(node, cutoffNodes);

                        case BLOCK_BEGIN:
                            if (isNodeForSmPLJavaDSLMetaElement(node)) {
                                return compileFormulaInner(node.next().get(0), cutoffNodes);
                            }

                            if (tag == null) {
                                throw new IllegalArgumentException("invalid tag for " + node.getKind().toString() + " node " +
                                                                   Integer.toString(node.getId()));
                            }

                            String parentIdVar = "__parent" + Integer.toString((int) tag.getMetadata("parent")) + "__";

                            boolean shouldQuantify = !quantifiedMetavars.contains(parentIdVar);

                            quantifiedMetavars.add(parentIdVar);

                            innerFormula = compileFormulaInner(node.next().get(0), cutoffNodes);

                            formula = new And(new Proposition(tag.getLabel()),
                                              new MetadataPredicate(parentIdVar, "parent"));

                            if (innerFormula != null) {
                                formula = new And(formula,
                                                  new AllNext(innerFormula));
                            }

                            if (shouldQuantify) {
                                formula = new ExistsVar(parentIdVar, formula);
                                quantifiedMetavars.remove(parentIdVar);
                            }

                            return formula;

                        case CONVERGE:
                            if (isNodeForSmPLJavaDSLMetaElement(node)) {
                                return compileFormulaInner(node.next().get(0), cutoffNodes);
                            }

                            formula = new Proposition("after");

                            innerFormula = compileFormulaInner(node.next().get(0), cutoffNodes);

                            if (innerFormula == null) {
                                return formula;
                            } else {
                                return new And(formula, new AllNext(innerFormula));
                            }

                        default:
                            throw new IllegalArgumentException("Unexpected control flow node kind for single successor: " + node.getKind().toString());
                    }

                default:
                    switch (node.getKind()) {
                        case STATEMENT:
                            // Will probably need this if adding support for exceptions
                            throw new NotImplementedException("Not implemented");

                        case BRANCH:
                            CtElement statement = node.getStatement();

                            if (SmPLJavaDSL.isDotsWithOptionalMatch(statement.getParent())) {
                                return compileDotsWithOptionalMatchFormula(node, cutoffNodes);
                            } else if (SmPLJavaDSL.isBeginDisjunction(statement.getParent())) {
                                return compileDisjunction(node, cutoffNodes);
                            } else {
                                return compileBranchFormula(node, cutoffNodes);
                            }

                        default:
                            throw new IllegalArgumentException("Unexpected control flow node kind for multiple successors: " + node.getKind().toString());
                    }
            }
        }
    }

    /**
     * Compile a formula for the special method header node.
     *
     * @param node Method header node
     * @param cutoffNodes Nodes at which formula compilation should stop
     * @return CTL-VW Formula
     */
    private Formula compileMethodHeaderFormula(ControlFlowNode node, List<ControlFlowNode> cutoffNodes) {
        Formula formula;

        if (!(node.getTag() instanceof SmPLMethodCFG.NodeTag)) {
            throw new IllegalArgumentException("invalid tag type for method header node");
        }

        SmPLMethodCFG.NodeTag tag = (SmPLMethodCFG.NodeTag) node.getTag();

        if (!(tag.getAnchor() instanceof CtMethod)) {
            throw new IllegalArgumentException("invalid anchor for method header node");
        }

        if (SmPLJavaDSL.isUnspecifiedMethodHeader(tag.getAnchor())) {
            formula = new Proposition("methodHeader");
        } else {
            formula = new MethodHeaderPredicate((CtMethod<?>) tag.getAnchor(), metavars);
            Set<String> metavarsUsed = ((MethodHeaderPredicate) formula).getMetavarsUsedInHeader();

            quantifiedMetavars.addAll(metavarsUsed);
            metavarsToQuantifyOutermost.addAll(metavarsUsed);
        }

        List<Operation> methodBodyOps = additions.getOperationsAnchoredToMethodBody();

        if (methodBodyOps != null && methodBodyOps.size() > 0) {
            formula = new And(formula, new ExistsVar("_v", new SetEnv("_v", methodBodyOps)));
        }

        return new And(formula, new AllNext(compileFormulaInner(node.next().get(0), cutoffNodes)));
    }

    /**
     * Compile a CTL-VW Formula for a given single-statement single-successor CFG node.
     *
     * @param node A single-statement, single-successor CFG node
     * @param cutoffNodes Nodes at which formula compilation should stop
     * @return CTL-VW Formula
     */
    private Formula compileStatementFormula(ControlFlowNode node, List<ControlFlowNode> cutoffNodes) {
        if (SmPLJavaDSL.isStatementLevelDots(node.getStatement())) {
            return compileStatementLevelDotsFormula(node, cutoffNodes);
        } else {
            CtElement statement = node.getStatement();
            int line = statement.getPosition().getLine();

            Formula formula = new Statement(statement, metavars);

            ArrayList<Operation> ops = new ArrayList<>();

            if (!commonLines.contains(line)) {
                ops.add(new DeleteOperation());
            }

            if (additions.containsKey(line)) {
                ops.addAll(additions.get(line));
            }

            if (ops.size() > 0) {
                formula = new And(formula, new ExistsVar("_v", new SetEnv("_v", ops)));
            }

            // Mark first occurences of metavars as quantified before compiling inner formula
            List<String> newMetavars = getUnquantifiedMetavarsUsedIn(statement);
            quantifiedMetavars.addAll(newMetavars);

            Formula innerFormula = compileFormulaInner(node.next().get(0), cutoffNodes);

            if (innerFormula != null) {
                formula = new And(formula, new AllNext(innerFormula));
            }

            // Actually quantify the new metavars
            Collections.reverse(newMetavars);

            for (String varname : newMetavars) {
                formula = new ExistsVar(varname, formula);
            }

            return formula;
        }
    }

    /**
     * Compile a CTL-VW Formula for a given branch statement multi-successor CFG node.
     *
     * @param node A branch statement, multi-successor CFG node
     * @param cutoffNodes Nodes at which formula compilation should stop
     * @return CTL-VW Formula
     */
    private Formula compileBranchFormula(ControlFlowNode node, List<ControlFlowNode> cutoffNodes) {
        Formula formula;

        CtElement statement = node.getStatement();
        int line = statement.getPosition().getLine();

        formula = new Branch(statement.getParent(), metavars);

        ArrayList<Operation> ops = new ArrayList<>();

        if (!commonLines.contains(line)) {
            ops.add(new DeleteOperation());
        }

        if (additions.containsKey(line)) {
            ops.addAll(additions.get(line));
        }

        if (ops.size() > 0) {
            formula = new And(formula, new ExistsVar("_v", new SetEnv("_v", ops)));
        }

        // Mark first occurences of metavars as quantified before compiling inner formulas
        List<String> newMetavars = getUnquantifiedMetavarsUsedIn(node.getStatement());
        quantifiedMetavars.addAll(newMetavars);

        Formula lhs = compileFormulaInner(node.next().get(0), cutoffNodes);
        Formula rhs = compileFormulaInner(node.next().get(1), cutoffNodes);

        if (lhs != null && rhs != null) {
            formula = new And(formula, new And(new ExistsNext(lhs), new ExistsNext(rhs)));
        } else if (lhs != null) {
            formula = new And(formula, new ExistsNext(lhs));
        } else if (rhs != null) {
            formula = new And(formula, new ExistsNext(rhs));
        }

        // Actually quantify the new metavars
        Collections.reverse(newMetavars);

        for (String varname : newMetavars) {
            formula = new ExistsVar(varname, formula);
        }

        return formula;
    }

    /**
     * Get the (to-be-negated) shortest-path guard formula for the element preceding a given statement-level
     * dots node.
     *
     * @param dotsNode Statement-level dots node
     * @return Shortest-path guard formula for preceding element
     */
    private Formula getPreGuard(ControlFlowNode dotsNode) {
        List<ControlFlowNode> prevNodes = dotsNode.prev();

        switch (prevNodes.size()) {
            case 1:
                ControlFlowNode prevNode = prevNodes.get(0);

                switch (prevNode.getKind()) {
                    case STATEMENT:
                        if (SmPLMethodCFG.isMethodHeaderNode(prevNode)) {
                            return null;
                        }

                        return compileFormulaInner(prevNode, Collections.singletonList(dotsNode));

                    case BLOCK_BEGIN:
                        switch (prevNode.prev().size()) {
                            case 1:
                                return compileFormulaInner(prevNode.prev().get(0), prevNode.prev().get(0).next());

                            default:
                                throw new NotImplementedException("preGuard not implemented for BLOCK_BEGIN with " + Integer.toString(prevNode.prev().size()) + " predecessors");
                        }


                    case CONVERGE:
                        // FIXME: relies on implementation details in spoon-control-flow
                        ControlFlowNode branchNode = prevNode.getParent().findNodeById(prevNode.getId() - 1);

                        if (SmPLJavaDSL.isBeginDisjunction(branchNode.getStatement().getParent())) {
                            // TODO: figure out if a disjunction should generate a guard
                            return null;
                        } else {
                            return compileFormulaInner(branchNode, branchNode.next());
                        }
                    default:
                        throw new NotImplementedException("preGuard not implemented for " + prevNode.getKind().toString() + " single predecessor");
                }

            default:
                throw new NotImplementedException("preGuard not implemented for " + prevNodes.size() + " predecessors");
        }
    }

    /**
     * Get the (to-be-negated) shortest-path guard formula for the element succeeding a given statement-level
     * dots node.
     *
     * @param dotsNode Statement-level dots node
     * @return Shortest-path guard formula for succeeding element
     */
    private Formula getPostGuard(ControlFlowNode dotsNode) {
        List<ControlFlowNode> nextNodes = dotsNode.next();

        switch (nextNodes.size()) {
            case 1:
                ControlFlowNode nextNode = nextNodes.get(0);

                switch (nextNode.getKind()) {
                    case STATEMENT:
                        return compileFormulaInner(nextNode, nextNode.next());

                    case CONVERGE:
                        return null;

                    case EXIT:
                        return null;

                    default:
                        throw new NotImplementedException("postGuard not implemented for " + nextNode.getKind().toString() + " single successor");
                }

            default:
                throw new NotImplementedException("postGuard not implemented for " + nextNodes.size() + " successors");
        }
    }

    /**
     * Remove all transformation operations from a given Formula.
     *
     * @param phi Formula to operate on
     * @return Formula without transformation operations
     */
    private static Formula removeOperations(Formula phi) {
        // TODO: might want to replace this with a full visitor that properly removes all ops regardless of nesting
        if (phi == null) {
            return null;
        }

        if (phi instanceof And && ((And) phi).getRhs() instanceof ExistsVar
            && ((ExistsVar) ((And) phi).getRhs()).getVarName().equals("_v")) {
            return ((And) phi).getLhs();
        } else {
            return phi;
        }
    }

    /**
     * Find the ID of the immediate parent branch for a given node.
     *
     * @param node Node for which to find the ID of the parent branch
     * @return ID of parent branch, or -1 if the closest parent of the node is the method body
     */
    private int findParentBranchId(ControlFlowNode node) {
        CtElement element = node.getStatement();
        CtElement blockParent = element.getParent().getParent();

        if (blockParent instanceof CtMethod) {
            return -1;
        }

        for (ControlFlowNode otherNode : node.getParent().findNodesOfKind(BranchKind.BRANCH)) {
            SmPLMethodCFG.NodeTag tag = (SmPLMethodCFG.NodeTag) otherNode.getTag();

            if (tag.getAnchor() == blockParent) {
                return (int) tag.getMetadata("branchId");
            }
        }

        throw new IllegalStateException("impossible situation / malformed cfg");
    }

    /**
     * Compile a CTL-VW formula for a statement-level dots operator.
     *
     * @param node Node representing a statement-level dots operator
     * @param cutoffNodes Nodes at which formula compilation should stop
     * @return CTL-VW Formula
     */
    private Formula compileStatementLevelDotsFormula(ControlFlowNode node, List<ControlFlowNode> cutoffNodes) {
        CtInvocation<?> dots = (CtInvocation<?>) node.getStatement();

        int branchId = findParentBranchId(node);
        String parentIdVar = "__parent" + Integer.toString(branchId) + "__";

        Formula guard = new And(new Proposition("after"), new MetadataPredicate(parentIdVar, "parent"));

        Formula contextPreGuard = null;
        Formula contextPostGuard = null;

        if (!SmPLJavaDSL.hasWhenAny(dots)) {
            contextPreGuard = getPreGuard(node);
            contextPostGuard = getPostGuard(node);

            // Remove any metavars "accidentally" marked as being quantified by compiling the postguard formula
            while (contextPostGuard instanceof ExistsVar) {
                quantifiedMetavars.remove(((ExistsVar) contextPostGuard).getVarName());
                contextPostGuard = ((ExistsVar) contextPostGuard).getInnerElement();
            }

            contextPreGuard = removeOperations(contextPreGuard);
            contextPostGuard = removeOperations(contextPostGuard);
        }

        guard = Or.connectIfNotNull(guard, contextPreGuard);
        guard = Or.connectIfNotNull(guard, contextPostGuard);

        Formula innerFormula = compileFormulaInner(node.next().get(0), cutoffNodes);

        List<String> whenNotEquals = SmPLJavaDSL.getWhenNotEquals(dots);

        if (whenNotEquals.size() > 0) {
            Iterator<String> it = whenNotEquals.iterator();

            guard = new Or(guard, new Proposition("unsupported"));

            while (it.hasNext()) {
                guard = new Or(new VariableUsePredicate(it.next(), metavars), guard);
            }
        }

        Formula formula = new Not(guard);

        if (SmPLJavaDSL.hasWhenExists(dots)) {
            formula = new ExistsUntil(formula, innerFormula);
        } else {
            formula = new AllUntil(formula, innerFormula);
        }

        return formula;
    }

    /**
     * Compile a formula for a dots-with-optional-match SmPL construct. This construct is represented in the
     * SmPL Java DSL as an elseless if-statement with the optional match contained in the body of the then-statement.
     *
     * @param node BRANCH node corresponding to the if-statement of the SmPL Java DSL representation of a
     *             dots-with-optional-match SmPL construct
     * @param cutoffNodes Nodes at which formula compilation should stop
     * @return CTL-VW Formula
     */
    private Formula compileDotsWithOptionalMatchFormula(ControlFlowNode node, List<ControlFlowNode> cutoffNodes) {
        // TODO: shortest path guard
        // TODO: modifiers/constraints e.g whenAny

        // The SmPL Java DSL construct for dots-with-optional-match is an elseless if, so the branch
        //   node must have exactly two successors where one is a convergence node and the other one
        //   is a BLOCK_BEGIN

        try {
            ControlFlowNode bodyNode = node.next()
                                           .stream()
                                           .filter(x -> x.getKind() == BranchKind.BLOCK_BEGIN)
                                           .findFirst().get();

            // Move past the BLOCK_BEGIN node
            bodyNode = bodyNode.next().get(0);

            ControlFlowNode convergenceNode = node.next()
                                                  .stream()
                                                  .filter(x -> x.getKind() == BranchKind.CONVERGE)
                                                  .findFirst().get();

            Formula optionalMatch = compileFormulaInner(bodyNode, Collections.singletonList(convergenceNode));
            Formula tail = compileFormulaInner(convergenceNode.next().get(0), cutoffNodes);

            // TODO: is there a case where metavariables need to be quantified enclosing the AllUntil here?
            //  maybe if the same unquantified metavariable is used in both the optional match and immediately
            //  in the tail? e.g optionalMatch = ExistsVar(x, ...), tail = ExistsVar(x, ...)
            return new AllUntil(new Optional(optionalMatch), tail);
        } catch (Exception e) {
            throw new IllegalArgumentException("malformed dots-with-optional-match node");
        }
    }

    /**
     * Compile a Formula for an SmPL pattern disjunction using the Sequential OR connective.
     *
     * @param node Node representing the start of a pattern disjunction
     * @param cutoffNodes Node at which formula compilation should stop
     * @return CTL-VW Formula
     */
    private Formula compileDisjunction(ControlFlowNode node, List<ControlFlowNode> cutoffNodes) {
        Deque<ControlFlowNode> workQueue = new ArrayDeque<>();
        List<ControlFlowNode> clauseStartingNodes = new ArrayList<>();

        workQueue.addAll(node.next());

        // Find the starting nodes of each clause
        while (!workQueue.isEmpty()) {
            ControlFlowNode currentNode = workQueue.getFirst();
            workQueue.removeFirst();

            if (currentNode.getKind() == BranchKind.BLOCK_BEGIN || (currentNode.getKind() == BranchKind.BRANCH && SmPLJavaDSL.isContinueDisjunction(currentNode.getStatement().getParent()))) {
                workQueue.addAll(currentNode.next());
            } else if (currentNode.getKind() == BranchKind.STATEMENT || currentNode.getKind() == BranchKind.BRANCH){
                clauseStartingNodes.add(currentNode);
            }
        }

        SequentialOr formula = new SequentialOr();

        // Compile each clause of the disjunction
        for (ControlFlowNode clauseNode : clauseStartingNodes) {
            formula.add(compileFormulaInner(clauseNode, cutoffNodes));
        }

        return formula;
    }

    /**
     * Get sorted list of metavariable names referenced in a given AST element.
     *
     * @param e Element to scan
     * @return Sorted list of metavariable names
     */
    private List<String> getMetavarsUsedIn(CtElement e) {
        List<String> metakeys = new ArrayList<>(metavars.keySet());
        List<String> result = new ArrayList<>(new VariableUseScanner(e, metakeys).getResult().keySet());
        result.retainAll(metakeys);

        Collections.sort(result);

        return result;
    }

    /**
     * Get sorted list of not-yet-quantified metavariable names referenced in a given AST element.
     *
     * @param e Element to scan
     * @return Sorted list of not-yet-quantified metavariable names
     */
    private List<String> getUnquantifiedMetavarsUsedIn(CtElement e) {
        List<String> result = getMetavarsUsedIn(e);
        result.removeAll(quantifiedMetavars);
        return result;
    }

    /**
     * Check if a given node is associated with an SmPL Java DSL meta element as opposed to something that should
     * be directly matched by the formula.
     *
     * @param node Node to check
     * @return True if the node is associated with a meta element, false otherwise
     */
    private boolean isNodeForSmPLJavaDSLMetaElement(ControlFlowNode node) {
        CtElement element = ((SmPLMethodCFG.NodeTag) node.getTag()).getAnchor();

        if (element instanceof CtBlock<?>) {
            element = element.getParent();
        }

        return SmPLJavaDSL.isBeginDisjunction(element)
               || SmPLJavaDSL.isContinueDisjunction(element)
               || SmPLJavaDSL.isDotsWithOptionalMatch(element);
    }

    /**
     * SmPL-adapted CFG to use for formula generation.
     */
    private SmPLMethodCFG cfg;

    /**
     * List of metavariable names that have already been quantified.
     */
    private List<String> quantifiedMetavars;

    /**
     * Metavariable names and their corresponding constraints.
     */
    private Map<String, MetavariableConstraint> metavars;

    /**
     * Set of line numbers associated with common (context) statements.
     */
    private Set<Integer> commonLines;

    /**
     * Map of anchored lists of addition operations.
     */
    private AnchoredOperationsMap additions;

    /**
     * Stored code element formula to be used as shortest-path guard for dots.
     */
    private Formula dotsPreGuard;

    /**
     * List of metavariables found during compilation of subformulas that must be quantified at the outermost
     * nesting level of the formula, i.e enclosing the full formula.
     */
    private List<String> metavarsToQuantifyOutermost;
}
