package spoon.smpl;

import fr.inria.controlflow.BranchKind;
import fr.inria.controlflow.ControlFlowNode;
import org.apache.commons.lang3.NotImplementedException;
import spoon.reflect.code.CtInvocation;
import spoon.reflect.code.CtLocalVariable;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.reference.CtVariableReference;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.smpl.formula.*;
import spoon.smpl.pattern.PatternBuilder;
import spoon.smpl.pattern.PatternNode;

import java.util.*;

/**
 * FormulaCompiler compiles CTL-VW Formulas from a given control flow graph of a method body in
 * the SmPL Java DSL (domain-specific language) of spoon-smpl, as generated by SmPLParser.
 */
public class FormulaCompiler {
    public FormulaCompiler() { this(new HashMap<>()); }
    /**
     * Create a new FormulaCompiler.
     * @param metavars Metavariable names and their constraints
     */
    public FormulaCompiler(Map<String, MetavariableConstraint> metavars) {
        this.quantifiedMetavars = new ArrayList<>();
        this.metavars = metavars;
        this.patternBuilder = new PatternBuilder(new ArrayList<String>(metavars.keySet()));
        this.queuedOperations = new ArrayList<>();
        this.operationsAnchor = null;
    }

    /**
     * Compile a CTL-VW Formula.
     * @param node First node of control flow graph to generate formula for
     * @return CTL-VW Formula
     */
    public Formula compileFormula(ControlFlowNode node) {
        quantifiedMetavars = new ArrayList<>();
        queuedOperations = new ArrayList<>();
        operationsAnchor = null;

        return compileFormulaInner(node);
    }

    /**
     * Compile a CTL-VW Formula.
     * @param node First node of control flow graph to generate formula for
     * @return CTL-VW Formula
     */
    private Formula compileFormulaInner(ControlFlowNode node) {
        if (node.getKind() == BranchKind.EXIT) {
            return null;
        }

        switch (node.next().size()) {
            case 0:
                throw new IllegalArgumentException("Control flow node with no outgoing path");

            case 1:
                switch (node.getKind()) {
                    case STATEMENT:
                        return compileStatementFormula(node);

                    default:
                        throw new IllegalArgumentException("Unexpected control flow node kind for single successor: " + node.getKind().toString());
                }

            default:
                switch (node.getKind()) {
                    case STATEMENT:
                        // Will probably need this if adding support for exceptions
                        throw new NotImplementedException("Not implemented");

                    case BRANCH:
                        node.getStatement().accept(patternBuilder);
                        PatternNode cond = patternBuilder.getResult();
                        Class<? extends CtElement> branchType = node.getStatement().getParent().getClass();

                        Formula formula = new BranchPattern(cond, branchType, metavars);
                        ((BranchPattern) formula).setStringRepresentation(node.getStatement().toString());

                        List<String> newMetavars = getUnquantifiedMetavarsUsedIn(node.getStatement());
                        quantifiedMetavars.addAll(newMetavars);

                        formula = new And(formula, new AllNext(new Or(compileFormulaInner(node.next().get(0)),
                                                                      compileFormulaInner(node.next().get(1)))));

                        Collections.reverse(newMetavars);

                        for (String varname : newMetavars) {
                            formula = new ExistsVar(varname, formula);
                        }

                        return formula;

                    default:
                        throw new IllegalArgumentException("Unexpected control flow node kind for multiple successors: " + node.getKind().toString());
                }
        }
    }

    /**
     * Compile a CTL-VW Formula for a given single-statement single-successor CFG node.
     * @param node A single-statement, single-successor CFG node
     * @return CTL-VW Formula
     */
    private Formula compileStatementFormula(ControlFlowNode node) {
        if (isDots(node.getStatement())) {
            // TODO: add guards needed for ensuring shortest path
            Formula innerFormula = compileFormulaInner(node.next().get(0));

            if (innerFormula == null) {
                return new True();
            } else {
                return new AllUntil(new True(), innerFormula);
            }
        } else if (isDeleteOperation(node.getStatement())) {
            queuedOperations.add(new DeleteOperationImpl());
            return compileFormulaInner(node.next().get(0));
        } else if (isAddOperation(node.getStatement())) {
            if (operationsAnchor == null) {
                queuedOperations.add(new PrependOperationImpl(node.next().get(0).getStatement()));
            } else {
                appendOperation(operationsAnchor, new AppendOperationImpl(node.next().get(0).getStatement()));
            }

            return compileFormulaInner(node.next().get(0).next().get(0));
        } else {
            node.getStatement().accept(patternBuilder);
            Formula formula = new StatementPattern(patternBuilder.getResult(), metavars);

            ((StatementPattern) formula).setStringRepresentation(node.getStatement().toString());

            if (queuedOperations.size() > 0) {
                formula = new And(formula, new ExistsVar("_v", new SetEnv("_v", queuedOperations)));
                queuedOperations = new ArrayList<>();
            }

            operationsAnchor = formula;

            // Mark first occurences of metavars as quantified before compiling inner formula
            List<String> newMetavars = getUnquantifiedMetavarsUsedIn(node.getStatement());
            quantifiedMetavars.addAll(newMetavars);

            Formula innerFormula = compileFormulaInner(node.next().get(0));

            if (innerFormula != null) {
                formula = new And(formula, new AllNext(innerFormula));
            }

            // Actually quantify the new metavars
            Collections.reverse(newMetavars);

            for (String varname : newMetavars) {
                formula = new ExistsVar(varname, formula);
            }

            return formula;
        }
    }

    /**
     * Check if an element represents an SmPL dots construct in the SmPL Java DSL.
     * @param e Element to check
     * @return True if element represents an SmPL dots construct, false otherwise
     */
    private static boolean isDots(CtElement e) {
        if (e instanceof CtInvocation<?>) {
            return ((CtInvocation<?>) e).getExecutable().getSimpleName().equals("__SmPLDots__");
        } else {
            return false;
        }
    }

    /**
     * Check if an element represents an SmPL delete operation in the SmPL Java DSL.
     * @param e Element to check
     * @return True if element represents an SmPL delete operation, false otherwise
     */
    private static boolean isDeleteOperation(CtElement e) {
        if (e instanceof CtInvocation<?>) {
            String simpleName = ((CtInvocation<?>) e).getExecutable().getSimpleName();
            return (simpleName.equals("__SmPLDelete__"));
        } else {
            return false;
        }
    }

    /**
     * Check if an element represents an SmPL addition operation in the SmPL Java DSL.
     * @param e Element to check
     * @return True if element represents an SmPL addition operation, false otherwise
     */
    private static boolean isAddOperation(CtElement e) {
        if (e instanceof CtInvocation<?>) {
            String simpleName = ((CtInvocation<?>) e).getExecutable().getSimpleName();
            return (simpleName.equals("__SmPLAdd__"));
        } else {
            return false;
        }
    }

    /**
     * Get sorted list of metavariable names referenced in a given AST element.
     * @param e Element to scan
     * @return Sorted list of metavariable names
     */
    private List<String> getMetavarsUsedIn(CtElement e) {
        List<String> result = new ArrayList<>();

        e.filterChildren(new TypeFilter<>(CtLocalVariable.class)).forEach((element) -> {
            String varname = ((CtLocalVariable<?>) element).getReference().getSimpleName();
            String typename = ((CtLocalVariable<?>) element).getType().getSimpleName();

            if (metavars.containsKey(varname) && !result.contains(varname)) {
                result.add(varname);
            }

            if (metavars.containsKey(typename) && !result.contains(typename)) {
                result.add(typename);
            }
        });

        e.filterChildren(new TypeFilter<>(CtVariableReference.class)).forEach((element) -> {
            String varname = element.toString();

            if (metavars.containsKey(varname) && !result.contains(varname)) {
                result.add(varname);
            }
        });

        Collections.sort(result);

        return result;
    }

    /**
     * Get sorted list of not-yet-quantified metavariable names referenced in a given AST element.
     * @param e Element to scan
     * @return Sorted list of not-yet-quantified metavariable names
     */
    private List<String> getUnquantifiedMetavarsUsedIn(CtElement e) {
        List<String> result = getMetavarsUsedIn(e);
        result.removeAll(quantifiedMetavars);
        return result;
    }

    /**
     * Append an operation to a given Formula.
     * @param target Target formula to append operation to
     * @param op Operation to append
     */
    @SuppressWarnings("unchecked")
    private static void appendOperation(Formula target, Operation op) {
        boolean validTarget = target instanceof And
                           && ((And) target).getRhs() instanceof ExistsVar
                           && ((ExistsVar) ((And) target).getRhs()).getVarName().equals("_v")
                           && ((ExistsVar) ((And) target).getRhs()).getInnerElement() instanceof SetEnv;

        if (validTarget) {
            SetEnv formula = (SetEnv) ((ExistsVar) ((And) target).getRhs()).getInnerElement();
            ((List<Operation>) formula.getValue()).add(op);
        } else {
            throw new IllegalArgumentException("Cannot append operation to " + target.toString());
        }
    }

    /**
     * List of metavariable names that have already been quantified.
     */
    private List<String> quantifiedMetavars;

    /**
     * Metavariable names and their corresponding constraints.
     */
    private Map<String, MetavariableConstraint> metavars;

    /**
     * A PatternBuilder to build patterns.
     */
    private PatternBuilder patternBuilder;

    /**
     * Operations queued to be assigned to the next available operation anchor.
     */
    private List<Operation> queuedOperations;

    /**
     * Current operation anchor.
     */
    private Formula operationsAnchor;
}
