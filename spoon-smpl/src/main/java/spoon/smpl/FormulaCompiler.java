package spoon.smpl;

import fr.inria.controlflow.BranchKind;
import fr.inria.controlflow.ControlFlowNode;
import org.apache.commons.lang3.NotImplementedException;
import spoon.reflect.code.*;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtMethod;
import spoon.smpl.formula.*;

import java.util.*;

/**
 * FormulaCompiler compiles CTL-VW Formulas from a given SmPL-adapted CFG of a method body in
 * the SmPL Java DSL (domain-specific language) of spoon-smpl, as generated by SmPLParser.
 */
public class FormulaCompiler {
    /**
     * Create a new FormulaCompiler.
     * @param cfg SmPL-adapted CFG to produce formula from
     * @param metavars Metavariable names and their constraints
     */
    public FormulaCompiler(SmPLMethodCFG cfg, Map<String, MetavariableConstraint> metavars, Set<Integer> commonLines, AnchoredOperationsMap additions) {
        this.cfg = cfg;
        this.quantifiedMetavars = new ArrayList<>();
        this.metavars = metavars;
        this.commonLines = commonLines;
        this.additions = additions;
        this.dotsPreGuard = null;
    }

    /**
     * Compile the CTL-VW Formula.
     * @return CTL-VW Formula
     */
    public Formula compileFormula() {
        quantifiedMetavars = new ArrayList<>();
        metavarsToQuantifyOutermost = new ArrayList<>();

        Formula formula = FormulaOptimizer.optimizeFully(compileFormulaInner(cfg.findNodesOfKind(BranchKind.BEGIN).get(0).next().get(0)));

        Collections.sort(metavarsToQuantifyOutermost);
        Collections.reverse(metavarsToQuantifyOutermost);

        for (String var : metavarsToQuantifyOutermost) {
            formula = new ExistsVar(var, formula);
        }

        return formula;
    }

    /**
     * Create a disjunction of a number of formula alternatives using the Sequential-Or connective.
     *
     * @param alternatives Formula alternatives to join in disjunction
     * @return Formula containing sequential-or disjunction of all alternatives
     */
    public static Formula joinAlternatives(List<Formula> alternatives) {
        if (alternatives.size() == 1) {
            return FormulaOptimizer.optimizeFully(alternatives.get(0));
        } else {
            return FormulaOptimizer.optimizeFully(new SequentialOr(alternatives));
        }
    }

    /**
     * Compile a CTL-VW Formula.
     * @param node First node of control flow graph to generate formula for
     * @return CTL-VW Formula
     */
    private Formula compileFormulaInner(ControlFlowNode node) {
        Formula formula;

        if (node.getKind() == BranchKind.EXIT) {
            return new Proposition("end");
        }

        if (SmPLMethodCFG.isMethodHeaderNode(node)) {
            if (!(node.getTag() instanceof SmPLMethodCFG.NodeTag)) {
                throw new IllegalArgumentException("invalid tag type for method header node");
            }

            SmPLMethodCFG.NodeTag tag = (SmPLMethodCFG.NodeTag) node.getTag();

            if (!(tag.getAnchor() instanceof CtMethod)) {
                throw new IllegalArgumentException("invalid anchor for method header node");
            }

            if (SmPLJavaDSL.isUnspecifiedMethodHeader(tag.getAnchor())) {
                formula = new Proposition("methodHeader");
            } else {
                formula = new MethodHeaderPredicate((CtMethod<?>) tag.getAnchor(), metavars);
                Set<String> metavarsUsed = ((MethodHeaderPredicate) formula).getMetavarsUsedInHeader();

                quantifiedMetavars.addAll(metavarsUsed);
                metavarsToQuantifyOutermost.addAll(metavarsUsed);
            }

            List<Operation> methodBodyOps = additions.getOperationsAnchoredToMethodBody();

            if (methodBodyOps != null && methodBodyOps.size() > 0) {
                formula = new And(formula, new ExistsVar("_v", new SetEnv("_v", methodBodyOps)));
            }

            return new And(formula, new AllNext(compileFormulaInner(node.next().get(0))));
        }

        switch (node.next().size()) {
            case 0:
                throw new IllegalArgumentException("Control flow node with no outgoing path");

            case 1:
                switch (node.getKind()) {
                    case STATEMENT:
                        return compileStatementFormula(node);

                    case BLOCK_BEGIN:
                        if (!(node.getTag() instanceof SmPLMethodCFG.NodeTag)) {
                            throw new IllegalArgumentException("invalid BLOCK_BEGIN tag for node " +
                                                                Integer.toString(node.getId()));
                        }

                        formula = new And(new Proposition(((SmPLMethodCFG.NodeTag) node.getTag()).getLabel()),
                                          new AllNext(compileFormulaInner(node.next().get(0))));
                        return formula;

                    case CONVERGE:
                        formula = new Proposition("after");

                        Formula innerFormula = compileFormulaInner(node.next().get(0));

                        if (innerFormula == null) {
                            return formula;
                        } else {
                            return new And(formula, new AllNext(innerFormula));
                        }

                    default:
                        throw new IllegalArgumentException("Unexpected control flow node kind for single successor: " + node.getKind().toString());
                }

            default:
                switch (node.getKind()) {
                    case STATEMENT:
                        // Will probably need this if adding support for exceptions
                        throw new NotImplementedException("Not implemented");

                    case BRANCH:
                        CtElement statement = node.getStatement();
                        int line = statement.getPosition().getLine();

                        formula = new Branch(statement.getParent(), metavars);
                        dotsPreGuard = formula;

                        ArrayList<Operation> ops = new ArrayList<>();

                        if (!commonLines.contains(line)) {
                            ops.add(new DeleteOperation());
                        }

                        if (additions.containsKey(line)) {
                            ops.addAll(additions.get(line));
                        }

                        if (ops.size() > 0) {
                            formula = new And(formula, new ExistsVar("_v", new SetEnv("_v", ops)));
                        }

                        // Mark first occurences of metavars as quantified before compiling inner formulas
                        List<String> newMetavars = getUnquantifiedMetavarsUsedIn(node.getStatement());
                        quantifiedMetavars.addAll(newMetavars);

                        Formula lhs = compileFormulaInner(node.next().get(0));
                        Formula rhs = compileFormulaInner(node.next().get(1));

                        formula = new And(formula, new AllNext(new Or(lhs, rhs)));

                        // Actually quantify the new metavars
                        Collections.reverse(newMetavars);

                        for (String varname : newMetavars) {
                            formula = new ExistsVar(varname, formula);
                        }

                        return formula;

                    default:
                        throw new IllegalArgumentException("Unexpected control flow node kind for multiple successors: " + node.getKind().toString());
                }
        }
    }

    /**
     * Compile a CTL-VW Formula for a given single-statement single-successor CFG node.
     * @param node A single-statement, single-successor CFG node
     * @return CTL-VW Formula
     */
    private Formula compileStatementFormula(ControlFlowNode node) {
        if (SmPLJavaDSL.isStatementLevelDots(node.getStatement())) {
            CtInvocation<?> dots = (CtInvocation<?>) node.getStatement();

            Formula savedPreGuard = dotsPreGuard;
            Formula innerFormula = compileFormulaInner(node.next().get(0));

            Formula postGuard = findFirstCodeElementFormula(innerFormula);

            Formula formula;

            if (!SmPLJavaDSL.hasWhenAny(dots)) {
                if (savedPreGuard != null) {
                    formula = savedPreGuard;

                    if (postGuard != null) {
                        formula = new Or(formula, postGuard);
                    }

                    formula = new Not(formula);
                } else {
                    formula = (postGuard == null) ? new True() : new Not(postGuard);
                }
            } else {
                formula = new True();
            }

            List<String> whenNotEquals = SmPLJavaDSL.getWhenNotEquals(dots);

            if (whenNotEquals.size() > 0) {
                Iterator<String> it = whenNotEquals.iterator();

                formula = new Not(new VariableUsePredicate(it.next(), metavars));

                while (it.hasNext()) {
                    formula = new And(formula, new Not(new VariableUsePredicate(it.next(), metavars)));
                }
            }

            if (innerFormula == null) {
                return formula;
            } else {
                if (SmPLJavaDSL.hasWhenExists(dots)) {
                    return new ExistsUntil(formula, innerFormula);
                } else {
                    return new AllUntil(formula, innerFormula);
                }
            }
        } else {
            CtElement statement = node.getStatement();
            int line = statement.getPosition().getLine();

            Formula formula = new Statement(statement, metavars);
            dotsPreGuard = formula;

            ArrayList<Operation> ops = new ArrayList<>();

            if (!commonLines.contains(line)) {
                ops.add(new DeleteOperation());
            }

            if (additions.containsKey(line)) {
                ops.addAll(additions.get(line));
            }

            if (ops.size() > 0) {
                formula = new And(formula, new ExistsVar("_v", new SetEnv("_v", ops)));
            }

            // Mark first occurences of metavars as quantified before compiling inner formula
            List<String> newMetavars = getUnquantifiedMetavarsUsedIn(statement);
            quantifiedMetavars.addAll(newMetavars);

            Formula innerFormula = compileFormulaInner(node.next().get(0));

            if (innerFormula != null) {
                formula = new And(formula, new AllNext(innerFormula));
            }

            // Actually quantify the new metavars
            Collections.reverse(newMetavars);

            for (String varname : newMetavars) {
                formula = new ExistsVar(varname, formula);
            }

            return formula;
        }
    }

    /**
     * Get sorted list of metavariable names referenced in a given AST element.
     * @param e Element to scan
     * @return Sorted list of metavariable names
     */
    private List<String> getMetavarsUsedIn(CtElement e) {
        List<String> metakeys = new ArrayList<>(metavars.keySet());
        List<String> result = new ArrayList<>(new VariableUseScanner(e, metakeys).getResult().keySet());
        result.retainAll(metakeys);

        Collections.sort(result);

        return result;
    }

    /**
     * Get sorted list of not-yet-quantified metavariable names referenced in a given AST element.
     * @param e Element to scan
     * @return Sorted list of not-yet-quantified metavariable names
     */
    private List<String> getUnquantifiedMetavarsUsedIn(CtElement e) {
        List<String> result = getMetavarsUsedIn(e);
        result.removeAll(quantifiedMetavars);
        return result;
    }

    // TODO: what about disjunctions, e.g Or(Statement1, Statement2)?
    /**
     * Find the first 'code element' predicate formula in a given formula tree.
     *
     * @param input Formula tree to search
     */
    private static Formula findFirstCodeElementFormula(Formula input) {
        if (input == null) {
            return null;
        } else if (input instanceof UnaryConnective) {
            return findFirstCodeElementFormula(((UnaryConnective) input).getInnerElement());
        } else if (input instanceof BinaryConnective) {
            if (input instanceof And && ((And) input).getLhs() instanceof Proposition) {
                if (((Proposition) ((And) input).getLhs()).getProposition().equals("after")) {
                    return null;
                }
            }
            Formula lhs = findFirstCodeElementFormula(((BinaryConnective) input).getLhs());
            return (lhs != null) ? lhs : findFirstCodeElementFormula(((BinaryConnective) input).getRhs());
        } else if (input instanceof Branch) {
            return input;
        } else if (input instanceof ExistsVar) {
            return findFirstCodeElementFormula(((ExistsVar) input).getInnerElement());
        } else if (input instanceof Proposition) {
            return null;
        } else if (input instanceof SetEnv) {
            return null;
        } else if (input instanceof Statement) {
            return input;
        } else if (input instanceof True) {
            return null;
        } else if (input instanceof VariableUsePredicate) {
            return null;
        } else {
            throw new IllegalArgumentException("unhandled formula element " + input.getClass().toString());
        }
    }

    /**
     * SmPL-adapted CFG to use for formula generation.
     */
    private SmPLMethodCFG cfg;

    /**
     * List of metavariable names that have already been quantified.
     */
    private List<String> quantifiedMetavars;

    /**
     * Metavariable names and their corresponding constraints.
     */
    private Map<String, MetavariableConstraint> metavars;

    /**
     * Set of line numbers associated with common (context) statements.
     */
    private Set<Integer> commonLines;

    /**
     * Map of anchored lists of addition operations.
     */
    private AnchoredOperationsMap additions;

    /**
     * Stored code element formula to be used as shortest-path guard for dots.
     */
    private Formula dotsPreGuard;

    private List<String> metavarsToQuantifyOutermost;
}
