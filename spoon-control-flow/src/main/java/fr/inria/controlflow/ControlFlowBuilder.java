/*
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package fr.inria.controlflow;

import spoon.reflect.code.CtAssert;
import spoon.reflect.code.CtAssignment;
import spoon.reflect.code.CtBlock;
import spoon.reflect.code.CtBreak;
import spoon.reflect.code.CtCase;
import spoon.reflect.code.CtConditional;
import spoon.reflect.code.CtContinue;
import spoon.reflect.code.CtDo;
import spoon.reflect.code.CtFor;
import spoon.reflect.code.CtForEach;
import spoon.reflect.code.CtIf;
import spoon.reflect.code.CtInvocation;
import spoon.reflect.code.CtLocalVariable;
import spoon.reflect.code.CtOperatorAssignment;
import spoon.reflect.code.CtReturn;
import spoon.reflect.code.CtStatement;
import spoon.reflect.code.CtSwitch;
import spoon.reflect.code.CtSwitchExpression;
import spoon.reflect.code.CtThrow;
import spoon.reflect.code.CtTry;
import spoon.reflect.code.CtUnaryOperator;
import spoon.reflect.code.CtWhile;
import spoon.reflect.declaration.CtClass;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.visitor.CtAbstractVisitor;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;

/**
 * Builds the control graph for a given snippet of code
 */
public class ControlFlowBuilder extends CtAbstractVisitor {

	private final ControlFlowGraph result = new ControlFlowGraph(ControlFlowEdge.class);

	private final ControlFlowNode exitNode = new ControlFlowNode(null, result, NodeKind.EXIT);

	private final ControlFlowNode beginNode = new ControlFlowNode(null, result, NodeKind.BEGIN);

	private ControlFlowNode lastNode = beginNode;

	private final HashMap<String, CtStatement> labeledStatement = new HashMap<>();

	//This stack pushes all the nodes to wich a break statement may jump to.
	private final Deque<ControlFlowNode> breakingBad = new ArrayDeque<>();
	//This stack pushes all the nodes to wich a continue statement may jump to.
	private final Deque<ControlFlowNode> continueBad = new ArrayDeque<>();

	/**
	 * Strategy for modeling exception control flow, if any.
	 */
	ExceptionControlFlowStrategy exceptionControlFlowStrategy;

	/**
	 * Set strategy for modeling exception control flow.
	 *
	 * @param strategy Strategy for modeling exception control flow
	 */
	public void setExceptionControlFlowStrategy(ExceptionControlFlowStrategy strategy) {
		exceptionControlFlowStrategy = strategy;
	}

	/**
	 * Get the last node generated by the builder.
	 *
	 * @return Last node generated by builder
	 */
	public ControlFlowNode getLastNode() {
		return lastNode;
	}

	/**
	 * Set the node that the builder should see as its latest addition, likely causing it to be given
	 * an edge to the next node generated by the builder. Intended to be used for implementing external
	 * strategies that modify the graph before passing control back to the builder.
	 *
	 * @param node Node to see as latest addition
	 */
	public void setLastNode(ControlFlowNode node) {
		lastNode = node;
	}

	public ControlFlowGraph getResult() {
		return result;
	}

	/**
	 * Build the control graph for the given element
	 *
	 * @param s starting point
	 * @return control flow graph
	 */
	public ControlFlowGraph build(CtElement s) {
		s.accept(this);
		tryAddEdge(lastNode, exitNode);

		if (exceptionControlFlowStrategy != null) {
			exceptionControlFlowStrategy.postProcess(result);
		}

		return result;
	}

	private void visitConditional(CtElement parent, CtConditional<?> conditional) {
		ControlFlowNode branch = new ControlFlowNode(parent, result, NodeKind.BRANCH);
		tryAddEdge(lastNode, branch);

		ControlFlowNode convergenceNode = new ControlFlowNode(null, result, NodeKind.CONVERGE);
		lastNode = branch;
		if (conditional.getThenExpression() instanceof CtConditional<?> conditionalThen) {
			visitConditional(conditional, conditionalThen);
		} else {
			lastNode = new ControlFlowNode(conditional.getThenExpression(), result, NodeKind.STATEMENT);
			tryAddEdge(branch, lastNode);
		}
		tryAddEdge(lastNode, convergenceNode);

		lastNode = branch;
		if (conditional.getElseExpression() instanceof CtConditional<?> conditionalElse) {
			visitConditional(conditional, conditionalElse);
		} else {
			lastNode = new ControlFlowNode(conditional.getElseExpression(), result, NodeKind.STATEMENT);
			tryAddEdge(branch, lastNode);
		}
		tryAddEdge(lastNode, convergenceNode);
		lastNode = convergenceNode;
	}

	/**
	 * Returns the first graph node representing the statement's construction.
	 * <p>
	 * Usually a statement is represented by many blocks and branches.
	 * This method returns the first of those blocks/branches.
	 *
	 * @param g         Graph in which the bloc is to be found
	 * @param statement Statement for which the first block is needed
	 * @return first graph node
	 * @throws NotFoundException when the initial node cannot be found
	 */
	public static ControlFlowNode firstNode(ControlFlowGraph g, CtElement statement) throws NotFoundException {

		if (statement == null) {
			throw new NotFoundException("statement null");
		}

		if (statement instanceof CtFor ctFor) {
			if (!ctFor.getForInit().isEmpty()) {
				return g.findNode(ctFor.getForInit().get(0));
			} else {
				return g.findNode(ctFor.getExpression());
			}
		} else if (statement instanceof CtForEach) {
			return g.findNode(((CtForEach) statement).getVariable());
		} else if (statement instanceof CtWhile) {
			return g.findNode(((CtWhile) statement).getLoopingExpression());
		} else if (statement instanceof CtDo) {
			ControlFlowNode n = g.findNode(((CtDo) statement).getLoopingExpression());
			ControlFlowNode n1 = null;
			for (ControlFlowEdge e : g.outgoingEdgesOf(n)) {
				if (e.isBackEdge()) {
					n1 = e.getTargetNode();
					break;
				}
			}
			if (n == n1 || n1 == null) {
				throw new NotFoundException("cannot find initial node of do while loop");
			}
			return n1;
		} else if (statement instanceof CtIf ifStatement) {
			return g.findNode(ifStatement.getCondition());
		} else if (statement instanceof CtSwitch<?> switchStatement) {
			return g.findNode(switchStatement.getSelector());
		} else if (statement instanceof CtBlock<?> blockStatement) {
			return g.findNode(blockStatement.getStatement(0));
		} else {
			return g.findNode(statement);
		}
	}


	private void defaultAction(NodeKind kind, CtStatement st) {
		ControlFlowNode n = new ControlFlowNode(st, result, kind);
		tryAddEdge(lastNode, n);
		lastNode = n;
	}

	/**
	 * Register the label of the statement
	 */
	private void registerStatementLabel(CtStatement st) {
		if (st.getLabel() == null || st.getLabel().isEmpty()) {
			return;
		}
		if (!labeledStatement.containsKey(st.getLabel())) {
			labeledStatement.put(st.getLabel(), st);
		}
	}

	/**
	 * Tries to add an edge. If source or target are not null and the vertex is unique
	 *
	 * @param source Source of the vertex
	 * @param target Target of the vertex
	 */
	private void tryAddEdge(ControlFlowNode source, ControlFlowNode target) {
		tryAddEdge(source, target, false, false);
	}

	/**
	 * Tries to add an edge. If source or target are not null and the vertex is unique
	 *
	 * @param source     Source of the vertex
	 * @param target     Target of the vertex
	 * @param isLooping  indicate that the edge is a back edge
	 * @param breakDance indicates that the edge is a jump out of the block
	 */
	private void tryAddEdge(ControlFlowNode source, ControlFlowNode target, boolean isLooping, boolean breakDance) {
		if (source != null && source.getKind() != NodeKind.CATCH && source.getStatement() != null && exceptionControlFlowStrategy != null) {
			exceptionControlFlowStrategy.handleStatement(this, source);
		}

		boolean isBreak = source != null && source.getStatement() instanceof CtBreak;
		boolean isContinue = source != null && source.getStatement() instanceof CtContinue;

		if (source != null && target != null
				&& !result.containsEdge(source, target)
				&& (isLooping || breakDance || !(isBreak || isContinue))) {
			ControlFlowEdge e = result.addEdge(source, target);
			e.setBackEdge(isLooping);
		}

	}

	@Override
	public <T> void visitCtAssert(CtAssert<T> asserted) {
		defaultAction(NodeKind.STATEMENT, asserted);
	}

	@Override
	public <T, A extends T> void visitCtAssignment(CtAssignment<T, A> assignment) {

		registerStatementLabel(assignment);

		if (assignment.getAssignment() instanceof CtConditional<?> conditionalAssignment) {
			visitConditional(assignment, conditionalAssignment);
		} else {
			defaultAction(NodeKind.STATEMENT, assignment);
		}
	}

	private <R> void travelStatementList(List<CtStatement> statements) {
		ControlFlowNode begin = new ControlFlowNode(null, result, NodeKind.BLOCK_BEGIN);
		tryAddEdge(lastNode, begin);
		lastNode = begin;
		for (CtStatement s : statements) {
			registerStatementLabel(s);
			s.accept(this); // <- This should modify last node
			//tryAddEdge(before, lastNode); //Probably the link is already added
		}
		ControlFlowNode end = new ControlFlowNode(null, result, NodeKind.BLOCK_END);
		tryAddEdge(lastNode, end);
		lastNode = end;
	}

	@Override
	public <R> void visitCtBlock(CtBlock<R> block) {
		travelStatementList(block.getStatements());
	}

	@Override
	public void visitCtBreak(CtBreak breakStatement) {
		ControlFlowNode to;
		try {
			to = firstNode(lastNode.getParent(), labeledStatement.get(breakStatement.getTargetLabel()));
		} catch (NotFoundException e) {
			to = null;
		}
		if (to != null) {
			defaultAction(NodeKind.STATEMENT, breakStatement);
			tryAddEdge(lastNode, to, true, false);
		} else if (!breakingBad.isEmpty()) {
			//Jump to the last guy who said I can jump to...
			defaultAction(NodeKind.STATEMENT, breakStatement);
			tryAddEdge(lastNode, breakingBad.peek(), false, true);
		}
	}

	@Override
	public <T> void visitCtClass(CtClass<T> ctClass) {
		defaultAction(NodeKind.STATEMENT, ctClass);
	}

	@Override
	public <T> void visitCtConstructor(CtConstructor<T> constructor) {
		constructor.getBody().accept(this);
	}

	@Override
	public void visitCtContinue(CtContinue continueStatement) {
		ControlFlowNode to;
		try {
			to = firstNode(result, labeledStatement.get(continueStatement.getTargetLabel()));
		} catch (NotFoundException ex) {
			to = continueBad.peek();
		}
		if (to != null) {
			defaultAction(NodeKind.STATEMENT, continueStatement);
			tryAddEdge(lastNode, to, true, false);
		}
	}

	@Override
	public void visitCtDo(CtDo doLoop) {
		registerStatementLabel(doLoop);

		ControlFlowNode convergenceNode = new ControlFlowNode(null, result, NodeKind.CONVERGE);
		continueBad.push(convergenceNode);
		//to break out of the do loop
		ControlFlowNode convergenceNodeOut = new ControlFlowNode(null, result, NodeKind.CONVERGE);
		breakingBad.push(convergenceNodeOut);


		tryAddEdge(lastNode, convergenceNode);
		ControlFlowNode branch = new ControlFlowNode(doLoop.getLoopingExpression(), result, NodeKind.BRANCH);
		tryAddEdge(branch, convergenceNode, true, false);
		tryAddEdge(branch, convergenceNodeOut);

		lastNode = convergenceNode;
		doLoop.getBody().accept(this);
		tryAddEdge(lastNode, branch);

		lastNode = convergenceNodeOut;

		//Remove do out of the breaking and continuing stack
		breakingBad.pop();
		continueBad.pop();
	}

	@Override
	public void visitCtFor(CtFor forLoop) {
		registerStatementLabel(forLoop);

		//Add the initialization code
		if (forLoop.getForInit() != null) {
			if (forLoop.getForInit().size() > 1) {
				travelStatementList(forLoop.getForInit());
			} else if (!forLoop.getForInit().isEmpty()) {
				forLoop.getForInit().get(0).accept(this);
			}
		}

		ControlFlowNode convergence = new ControlFlowNode(forLoop.getExpression(), result, NodeKind.CONVERGE);
		breakingBad.push(convergence);

		//Next the branch
		ControlFlowNode branch = new ControlFlowNode(forLoop.getExpression(), result, NodeKind.BRANCH);
		tryAddEdge(lastNode, branch);

		//Node continue statements can continue to
		continueBad.push(branch);

		//Body
		lastNode = branch;
		if (forLoop.getBody() != null) {
			forLoop.getBody().accept(this);
		}

		//Append the update at the end
		if (forLoop.getForUpdate() != null) {
			if (forLoop.getForUpdate().size() > 1) {
				travelStatementList(forLoop.getForUpdate());
			} else if (!forLoop.getForUpdate().isEmpty()) {
				forLoop.getForUpdate().get(0).accept(this);
			}
		}

		//Link to the branch
		tryAddEdge(lastNode, branch, true, false);

		//Add a convergence node to quit the loop
		lastNode = convergence;
		tryAddEdge(branch, lastNode);

		continueBad.pop();
		breakingBad.pop();
	}


	@Override
	public void visitCtForEach(CtForEach foreach) {
		registerStatementLabel(foreach);

		ControlFlowNode convergence = new ControlFlowNode(null, result, NodeKind.CONVERGE);
		breakingBad.push(convergence);

		ControlFlowNode init = new ControlFlowNode(foreach.getVariable(), result, NodeKind.STATEMENT);
		tryAddEdge(lastNode, init);
		lastNode = init;

		ControlFlowNode branch = new ControlFlowNode(foreach.getExpression(), result, NodeKind.BRANCH);
		continueBad.push(branch);
		tryAddEdge(lastNode, branch);

		//Body
		lastNode = branch;
		foreach.getBody().accept(this);

		tryAddEdge(lastNode, branch, true, false);

		//Exit node
		lastNode = convergence;
		tryAddEdge(branch, lastNode);

		breakingBad.pop();
		continueBad.pop();
	}

	@Override
	public void visitCtIf(CtIf ifElement) {
		registerStatementLabel(ifElement);

		ControlFlowNode branch = new ControlFlowNode(ifElement.getCondition(), result, NodeKind.BRANCH);
		tryAddEdge(lastNode, branch);

		ControlFlowNode convergenceNode = new ControlFlowNode(null, result, NodeKind.CONVERGE);
		if (ifElement.getThenStatement() != null) {
			lastNode = branch;
			ifElement.getThenStatement().accept(this);
			tryAddEdge(lastNode, convergenceNode);
		}

		if (ifElement.getElseStatement() != null) {
			lastNode = branch;
			ifElement.getElseStatement().accept(this);
			tryAddEdge(lastNode, convergenceNode);
		} else {
			tryAddEdge(branch, convergenceNode);
		}
		lastNode = convergenceNode;
	}

	@Override
	public <T> void visitCtInvocation(CtInvocation<T> invocation) {
		registerStatementLabel(invocation);
		defaultAction(NodeKind.STATEMENT, invocation);
	}

	@Override
	public <T> void visitCtLocalVariable(CtLocalVariable<T> localVariable) {
		registerStatementLabel(localVariable);
		if (localVariable.getDefaultExpression() instanceof CtConditional<?> conditionalDefaultExpression) {
			visitConditional(localVariable, conditionalDefaultExpression);
		} else {
			defaultAction(NodeKind.STATEMENT, localVariable);
		}
	}

	@Override
	public <T> void visitCtMethod(CtMethod<T> m) {
		m.getBody().accept(this);
	}

	@Override
	public <T, A extends T> void visitCtOperatorAssignment(CtOperatorAssignment<T, A> assignment) {
		registerStatementLabel(assignment);
		defaultAction(NodeKind.STATEMENT, assignment);
	}

	@Override
	public <R> void visitCtReturn(CtReturn<R> returnStatement) {
		registerStatementLabel(returnStatement);
		ControlFlowNode n = new ControlFlowNode(returnStatement, result, NodeKind.STATEMENT);
		tryAddEdge(lastNode, n);
		tryAddEdge(n, exitNode);
		lastNode = null; //Special case in which this node does not connect with the next, because is a return
	}

	@Override
	public <S> void visitCtCase(CtCase<S> caseStatement) {
		registerStatementLabel(caseStatement);
		ControlFlowNode caseNode = new ControlFlowNode(caseStatement.getCaseExpression(), result, NodeKind.STATEMENT);
		tryAddEdge(lastNode, caseNode);
		lastNode = caseNode;
		travelStatementList(caseStatement.getStatements());
	}

	@Override
	public <S> void visitCtSwitch(CtSwitch<S> switchStatement) {
		registerStatementLabel(switchStatement);
		//Push the condition
		ControlFlowNode switchNode = new ControlFlowNode(switchStatement.getSelector(), result, NodeKind.BRANCH);
		tryAddEdge(lastNode, switchNode);

		//Create a convergence node for all the branches to converge after this
		ControlFlowNode convergenceNode = new ControlFlowNode(null, result, NodeKind.CONVERGE);
		//Push the convergence node so all non labeled breaks jumps there
		breakingBad.push(convergenceNode);

		lastNode = switchNode;
		for (CtCase caseStatement : switchStatement.getCases()) {

			//Visit Case
			registerStatementLabel(caseStatement);
			ControlFlowNode cn = new ControlFlowNode(caseStatement.getCaseExpression(), result, NodeKind.STATEMENT);
			tryAddEdge(lastNode, cn);
			if (lastNode != switchNode) {
				tryAddEdge(switchNode, cn);
			}
			lastNode = cn;
			travelStatementList(caseStatement.getStatements());
			if (lastNode.getStatement() instanceof CtBreak) {
				lastNode = switchNode;
			}
		}
		tryAddEdge(lastNode, convergenceNode);

		//Return as last node the convergence node
		lastNode = convergenceNode;
		breakingBad.pop();
	}

	@Override
	public <T, S> void visitCtSwitchExpression(CtSwitchExpression<T, S> switchExpression) {
		//TODO: missing, implementation needed
	}

	@Override
	public void visitCtThrow(CtThrow throwStatement) {
		if (exceptionControlFlowStrategy != null) {
			exceptionControlFlowStrategy.handleThrowStatement(this, throwStatement);
		}
	}

	@Override
	public void visitCtTry(CtTry tryBlock) {
		if (exceptionControlFlowStrategy != null) {
			exceptionControlFlowStrategy.handleTryStatement(this, tryBlock);
		}
	}

	@Override
	public <T> void visitCtUnaryOperator(CtUnaryOperator<T> operator) {
		defaultAction(NodeKind.STATEMENT, operator);
	}

	@Override
	public void visitCtWhile(CtWhile whileLoop) {
		registerStatementLabel(whileLoop);

		ControlFlowNode convergenceNode = new ControlFlowNode(null, result, NodeKind.CONVERGE);
		breakingBad.push(convergenceNode);

		ControlFlowNode branch = new ControlFlowNode(whileLoop.getLoopingExpression(), result, NodeKind.BRANCH);
		continueBad.push(branch);

		tryAddEdge(lastNode, branch);
		tryAddEdge(branch, convergenceNode);
		lastNode = branch;
		if (whileLoop.getBody() != null) {
			whileLoop.getBody().accept(this);
		}
		tryAddEdge(lastNode, branch, true, false);
		lastNode = convergenceNode;

		breakingBad.pop();
		continueBad.pop();
	}

}
